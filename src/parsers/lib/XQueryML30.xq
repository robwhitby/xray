xquery version "1.0" encoding "UTF-8";

(: This file was generated on Mon Feb 20, 2012 17:02 (UTC+01) by REx v5.14 which is Copyright (c) 1979-2012 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: XQueryML30.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the XQueryML30 grammar.
 :)
module namespace p="XQueryML30";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 31, 32, 33, 30, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 37, 40,
  41, 42, 43, 44, 45, 46, 47, 48, 30, 30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 37,
  37
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 324, 370,
  386, 422, 422, 422, 414, 354, 346, 354, 346, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 439, 439, 439, 439, 439, 439, 439, 339, 354, 354, 354, 354, 354, 354, 354, 354, 400, 422, 422, 423, 421,
  422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422,
  422, 422, 422, 422, 422, 422, 353, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354,
  354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 68, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30, 30, 30, 30, 30, 31, 32,
  33, 30, 30, 30, 30, 34, 30, 30, 30, 35, 30, 30, 36, 37, 38, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
  39, 37, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 37, 40, 41, 42, 43, 44, 45, 46, 47, 48, 30,
  30, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
  37, 37, 39, 39, 37, 37, 37, 37, 37, 37, 37, 67, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 67,
  67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 37, 39, 37, 39, 39, 37
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 8194, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
  2073, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
  160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182,
  183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,
  206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228,
  229, 230, 231, 232, 233, 234
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 8832, 8875, 8879, 8880,
  8859, 8879, 8879, 8879, 8846, 8857, 8879, 8903, 8896, 8919, 20406, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 9415,
  9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972,
  15190, 9006, 9021, 9415, 24515, 9415, 26941, 9415, 17914, 9415, 9415, 9057, 9415, 9415, 9415, 11783, 9415, 9415, 9585,
  9773, 9076, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 8929, 15594, 9109, 9415, 20444, 9128, 9415, 11130, 12066, 9148, 12064, 9415, 25495, 9182,
  9195, 9415, 9221, 9415, 17914, 9415, 9246, 9415, 9415, 9415, 9415, 13449, 9415, 9415, 12458, 21739, 9267, 23173, 9415,
  15625, 9415, 9415, 9415, 9415, 24820, 9415, 9415, 9415, 9526, 9415, 9415, 9533, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9290, 25132, 9344, 9415, 20444, 9312, 9415, 25842, 9415, 8972, 23452, 9334, 9360, 9342, 23183, 9396, 26941, 9415,
  21312, 9415, 10198, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 12694, 9415, 15625, 9415, 9415, 9415,
  9415, 14893, 9414, 9415, 9415, 23122, 9415, 9415, 17936, 9432, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9725, 9415, 16293, 9415,
  20444, 15389, 9415, 26589, 25697, 9449, 9415, 9415, 25701, 24549, 9484, 9415, 26941, 9415, 17914, 9415, 9415, 9415,
  9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415, 24566,
  13990, 9515, 9415, 9549, 9415, 22053, 24271, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 9415, 9415, 11783,
  9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 9573, 9415, 9415,
  9415, 9415, 10204, 9415, 21303, 9415, 17914, 9415, 9415, 9415, 9415, 9415, 9415, 13707, 9415, 9415, 12799, 15910,
  9601, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 8929, 15228, 9628, 9415, 20444, 9647, 9415, 11344, 12414, 9667, 12412, 9415, 25553, 9702, 9715,
  9415, 14098, 9415, 17914, 9415, 18498, 9415, 9415, 9415, 9415, 13246, 9415, 9415, 9034, 15892, 9748, 18365, 9415,
  15625, 9415, 9415, 9415, 9415, 9415, 20442, 9415, 9415, 9274, 9415, 9415, 11820, 9771, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  24281, 9557, 9791, 9798, 9799, 9815, 9798, 9828, 9825, 9844, 9855, 9871, 9884, 9913, 9927, 9415, 26941, 9415, 18347,
  9415, 9415, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 9957, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 18357, 9415, 20444,
  15880, 9415, 9415, 15890, 9979, 10016, 10029, 10040, 10331, 10056, 10086, 26941, 9415, 17192, 9415, 9415, 9415, 9415,
  9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15280, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 22163, 9415, 20444, 9415, 9415, 9415, 9415,
  8972, 23097, 10103, 10118, 10134, 10147, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 9415, 9415, 11783, 9415,
  9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 21760, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 20371, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 20985, 10163, 10185,
  9060, 10169, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415,
  9415, 18902, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 8929, 9415, 19181, 9415, 20444, 24726, 9415, 9415, 10304, 10220, 10276, 10265, 10292, 9415, 13193, 9415, 26941,
  9415, 17914, 9415, 9415, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 10321, 9415, 9415,
  9415, 20444, 9415, 9415, 9415, 9415, 8972, 23642, 10347, 10369, 9112, 10353, 10398, 26941, 9415, 17914, 9415, 9415,
  9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417, 10442, 9415, 18902, 9415, 16172, 12386, 14008,
  9415, 19036, 19039, 21851, 13316, 19384, 19384, 20789, 24816, 9415, 9415, 9415, 17672, 12391, 20634, 18598, 19039,
  19039, 12327, 10462, 19384, 19384, 13490, 18561, 10485, 9415, 9415, 10506, 19367, 19037, 19039, 19039, 13480, 19384,
  19384, 24808, 9415, 9415, 19834, 20631, 19038, 11089, 17607, 19933, 13485, 24818, 24876, 24227, 19033, 19039, 10526,
  17288, 10725, 11177, 19030, 19039, 19384, 17832, 10544, 10572, 10606, 21918, 10632, 20967, 21466, 10677, 10701, 16862,
  21571, 27096, 10748, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9089, 9415, 9415, 9083, 8972, 9415, 9415, 9415, 26992, 10781,
  9415, 26941, 9415, 24290, 9415, 9415, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10797, 9415, 9415,
  15625, 9415, 9415, 12386, 14008, 9415, 19036, 19039, 21851, 13316, 19384, 19384, 13488, 24816, 9415, 9415, 9415, 9415,
  12391, 20634, 18598, 19039, 19039, 12327, 10462, 19384, 19384, 13490, 9415, 9415, 9415, 9415, 12390, 19367, 19037,
  19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24818, 9415,
  24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466,
  10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9963, 10841, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 18434,
  10905, 10861, 10890, 10917, 9415, 26941, 9415, 17914, 9415, 9415, 10933, 9415, 9631, 9415, 11783, 9415, 9415, 9585,
  9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 8929, 9415, 10952, 9415, 20444, 27032, 9415, 9415, 27026, 8972, 9415, 9415, 9415, 25157,
  10969, 9415, 13791, 9415, 13800, 9415, 9415, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10985, 9415,
  9415, 19865, 14633, 9415, 12386, 14008, 9415, 19036, 19039, 21851, 13316, 19384, 19384, 13488, 11009, 11025, 27364,
  17739, 9415, 12391, 20634, 11043, 19039, 19039, 14178, 11067, 19384, 19384, 14223, 25726, 9415, 9415, 13108, 12390,
  18400, 11087, 19039, 19039, 18108, 19384, 19384, 17703, 11105, 9415, 9415, 21516, 11088, 19039, 14422, 19384, 19938,
  24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918,
  10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 24856, 9415, 10087, 9398, 11148, 9415,
  11146, 8972, 9415, 9415, 11165, 9415, 18910, 26468, 13183, 9415, 25438, 9415, 9415, 9415, 9415, 9415, 9415, 12116,
  11231, 11221, 11588, 11363, 11247, 9415, 9415, 24850, 9415, 9415, 9415, 9415, 17954, 11277, 11231, 11296, 11327,
  11360, 11360, 11596, 11379, 9415, 9415, 9415, 9415, 9415, 9415, 9609, 11231, 11231, 11280, 11399, 11360, 11360, 11444,
  9415, 9415, 9415, 9415, 9415, 9415, 11229, 11231, 11231, 11398, 11360, 11360, 11449, 9415, 9415, 9415, 9415, 11230,
  11231, 11415, 11360, 11439, 11381, 9415, 9415, 9611, 11231, 11311, 11465, 9415, 9415, 9608, 11231, 11360, 11339, 9415,
  11231, 11310, 11339, 11227, 11525, 9612, 11528, 11302, 11576, 11307, 9610, 11423, 11544, 11545, 11561, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9251, 9415, 20444,
  11612, 11715, 9415, 9415, 11676, 11703, 11734, 11745, 9415, 11687, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 9415,
  9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 23470, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 27036, 11761, 9415, 23999, 9415, 9415, 9415, 20437, 9415, 9415, 9415, 11800, 9415, 9415,
  11255, 9230, 9415, 9415, 11780, 9415, 24820, 20443, 9415, 9415, 11799, 9415, 9415, 11261, 11816, 9415, 9415, 24819,
  20443, 9415, 9584, 9415, 9775, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415,
  9415, 9415, 21382, 12043, 11836, 11847, 25137, 11863, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 13902, 9415,
  11783, 9415, 9415, 9585, 9773, 11903, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9494, 9499, 26854, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 14919,
  11926, 11937, 9415, 15965, 9415, 12656, 9415, 17914, 9415, 9415, 9415, 9415, 17183, 9415, 11783, 9415, 9415, 9585,
  9773, 11953, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9205, 17796, 17803, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 16335, 11976, 11987, 17804,
  21898, 12003, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 21649, 9415, 11783, 9415, 9415, 9585, 9773, 12033, 9415,
  9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 12092, 12097, 9415, 9415, 20444, 26075, 9415, 9415, 9415, 8972, 9415, 26075, 12059, 9415, 12082, 9415, 26941,
  9415, 17914, 9415, 9415, 12113, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 12132, 9415, 9415, 15625, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415,
  9415, 20444, 9415, 9415, 9415, 9415, 8972, 9415, 9415, 9415, 8933, 12155, 9415, 26941, 9415, 17914, 9415, 9415, 9415,
  9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415,
  9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265,
  19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 22139,
  19384, 19384, 16000, 12213, 12262, 9415, 17857, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384,
  10616, 17541, 9415, 9415, 13108, 12390, 14132, 12325, 19039, 19039, 16069, 19384, 19384, 16211, 11105, 9415, 25186,
  21516, 11088, 19039, 14422, 19384, 19938, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 25871, 19030, 19039,
  19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570,
  14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415,
  9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415,
  13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386,
  14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262, 9415, 17857, 9415, 12391, 20634, 12281,
  19039, 19039, 16656, 12305, 19384, 19384, 10616, 17541, 9415, 9415, 13108, 12390, 14132, 12325, 19039, 19039, 16069,
  19384, 19384, 16211, 11105, 9415, 9415, 21516, 11088, 19039, 14422, 19384, 19938, 24818, 9415, 24227, 19033, 19039,
  21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566,
  16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 15460, 16956,
  14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417,
  13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262,
  9415, 17857, 20878, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 17541, 9415, 9415, 13108,
  12390, 14132, 12325, 19039, 19039, 16069, 19384, 19384, 16211, 11105, 9415, 9415, 21516, 11088, 19039, 14422, 19384,
  19938, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574,
  21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415,
  9415, 9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415,
  12265, 19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851,
  22139, 19384, 19384, 16000, 12213, 12262, 9415, 17857, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384,
  19384, 10616, 17541, 9415, 9415, 26367, 12390, 14132, 12325, 19039, 19039, 16069, 19384, 19384, 16211, 11105, 9415,
  9415, 21516, 11088, 19039, 14422, 19384, 19938, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030,
  19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569,
  13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125,
  9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 14107,
  9415, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417, 13079, 9415, 19827, 13227, 9415,
  12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262, 9415, 17857, 9415, 12391, 20634,
  12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 17541, 9415, 9415, 13108, 12390, 14132, 12325, 19039, 19039,
  16069, 19384, 19384, 16211, 11105, 9415, 9415, 21516, 11088, 19039, 14422, 19384, 19938, 24818, 9415, 24227, 19033,
  19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469,
  21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 15460,
  16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449,
  10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213,
  12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 9415, 9415, 9415, 9415,
  12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384,
  13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574,
  21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415,
  9415, 9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415,
  12265, 19039, 10585, 15992, 14449, 12343, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851,
  22139, 19384, 19384, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384,
  19384, 10616, 9415, 9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415,
  20631, 19038, 19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039,
  19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570,
  14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415,
  9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 15460, 16956, 16099, 9415, 26941, 9415, 17914, 9415,
  13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386,
  14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281,
  19039, 19039, 16656, 12305, 19384, 19384, 10616, 9415, 9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480,
  19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039,
  21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566,
  16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 12367, 9941, 9415, 15460, 16956,
  14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417,
  13079, 9415, 15625, 13227, 23962, 12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262,
  9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 9415, 9415, 9415, 9415, 12390,
  19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485,
  24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918,
  10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415,
  9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265,
  19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 22139,
  19384, 19384, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384,
  10616, 9415, 9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631,
  19038, 19039, 17607, 19384, 13485, 24818, 9415, 12383, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384,
  21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 12407, 9415, 9415,
  9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023,
  9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008,
  8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039,
  19039, 16656, 12305, 19384, 19384, 10616, 9415, 9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384,
  19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575,
  12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862,
  21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 27196, 12430, 12445, 9415, 10000,
  9415, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625,
  9415, 22678, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 12481, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929,
  9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9415, 9415, 9415, 9415, 10204, 9415, 26941, 9415, 17914, 9415,
  9415, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 12499, 9415, 10401, 9415, 20444, 9415,
  9415, 9415, 9415, 12529, 12556, 12569, 12580, 9415, 16232, 21195, 26941, 9415, 17914, 9415, 9415, 9415, 9415, 9415,
  9415, 11783, 9415, 9415, 9585, 9773, 12596, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972,
  9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 12389, 20636, 9415, 12265, 19039, 10585,
  15992, 14449, 10417, 9415, 9415, 15625, 9415, 9415, 12386, 14008, 9415, 18603, 19039, 21851, 16792, 19384, 19384,
  13488, 24816, 9415, 9415, 9415, 9415, 12391, 20634, 19339, 19039, 19039, 16656, 10462, 19384, 19384, 13490, 9415,
  9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038,
  19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918,
  24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9416, 12624,
  20444, 9416, 12619, 9415, 12641, 12683, 12710, 12726, 12741, 12757, 12770, 9373, 10235, 13613, 15406, 9415, 12786,
  10382, 12822, 12846, 12868, 12878, 12905, 12894, 12921, 12968, 12984, 13079, 9415, 15625, 13014, 23541, 12944, 10510,
  8990, 12194, 19039, 13045, 22139, 19384, 19385, 16000, 12213, 13068, 9415, 13095, 9415, 13127, 25907, 12281, 13151,
  13593, 13168, 13209, 19384, 23359, 10616, 17541, 13225, 24103, 13243, 13262, 20228, 13306, 13332, 19039, 16928, 19294,
  19384, 13352, 13379, 13406, 27019, 21516, 11088, 22230, 13422, 19384, 19988, 24981, 13446, 24227, 19033, 13465, 21575,
  13506, 9415, 22887, 11887, 20680, 20331, 13540, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 23036, 13561, 18248,
  21571, 13586, 15789, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 11125, 9415, 9415, 13609, 20444, 9415, 27357, 9415, 9415, 13629, 9941, 25303, 16897, 13656,
  13669, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417,
  13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262,
  9415, 25311, 26667, 13685, 17533, 12281, 19039, 11051, 16656, 12305, 19384, 26636, 10616, 17541, 9415, 9415, 13108,
  12390, 14132, 12325, 19039, 19039, 16069, 19384, 19384, 16211, 11105, 9415, 13704, 13723, 13739, 15045, 23221, 19384,
  19938, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574,
  21918, 10821, 10466, 10590, 10469, 21566, 15539, 23863, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 13760, 9415, 9415, 25294, 20444, 9415, 26950,
  9415, 12240, 13776, 13816, 13832, 13847, 13863, 13876, 9415, 26941, 9415, 13892, 12483, 13926, 9415, 12389, 20636,
  9415, 12265, 19039, 10585, 22814, 16681, 10417, 13079, 13948, 17171, 13227, 24342, 13968, 14006, 14024, 14040, 19039,
  22364, 19480, 14056, 19384, 16000, 14083, 12262, 22182, 17857, 18648, 14123, 20634, 14148, 14176, 14194, 17084, 14213,
  14239, 16505, 10616, 17541, 9415, 9415, 14264, 12390, 14132, 12325, 19039, 19040, 16069, 19384, 14430, 16211, 11105,
  9415, 9415, 21516, 11088, 19039, 14422, 19384, 19938, 24818, 9415, 24227, 14284, 19039, 21575, 14300, 14333, 22887,
  25342, 14357, 26304, 21918, 24228, 19039, 14446, 14465, 10821, 10466, 10590, 10469, 21566, 21603, 14486, 10588, 23725,
  13569, 13570, 25389, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  11125, 9415, 9415, 8956, 20444, 9415, 23131, 21200, 24686, 14512, 14528, 14544, 14555, 14571, 14584, 9415, 26941,
  9415, 17914, 9415, 13023, 9415, 20841, 20636, 22984, 14600, 23309, 10585, 14649, 14673, 14689, 13079, 26705, 15625,
  14741, 9415, 18391, 14766, 24029, 14798, 16782, 21851, 14839, 15718, 14868, 16000, 12213, 12262, 22686, 26211, 9415,
  12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 17541, 14892, 14909, 13108, 12390, 14132, 14935,
  19039, 14958, 16823, 19384, 25772, 16211, 11105, 9415, 25019, 14979, 14995, 15017, 23263, 23903, 19938, 24818, 20182,
  19203, 18474, 15039, 15061, 15088, 9415, 22887, 19030, 19039, 19384, 23074, 24228, 18135, 21574, 15118, 10821, 10466,
  10590, 10469, 15139, 16862, 15169, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 13545, 20444, 9415, 15206, 9415, 15244, 15265,
  15301, 15317, 15332, 15348, 15361, 10953, 26941, 24336, 15377, 15422, 13023, 12667, 12017, 15446, 15489, 15513, 14823,
  14812, 15555, 15571, 10417, 24259, 15955, 15587, 15610, 23445, 12386, 13688, 22783, 15647, 13744, 15695, 15734, 23273,
  15772, 15805, 15821, 15852, 15868, 26354, 15908, 15926, 15942, 15981, 16016, 16054, 25360, 16090, 16115, 16151, 16196,
  23768, 16248, 9415, 16264, 16315, 22581, 16351, 23316, 16389, 16491, 16419, 16439, 20553, 11105, 12139, 16455, 19242,
  16476, 16528, 14422, 16585, 18290, 14630, 9296, 24227, 16627, 16654, 16672, 16697, 16713, 16729, 16750, 16808, 16851,
  16883, 18462, 17329, 17008, 15072, 16913, 23886, 16944, 16982, 26727, 26154, 17024, 17049, 17100, 17140, 17128, 14852,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 15285, 9415,
  9415, 20444, 9415, 25192, 10305, 14470, 17156, 17219, 17208, 17235, 17251, 17264, 9415, 26941, 9651, 17914, 9415,
  13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 17280, 17304, 10417, 13079, 20575, 20568, 13227, 20484, 14702,
  14008, 8990, 17320, 19039, 21851, 22139, 17345, 19384, 16000, 12213, 12262, 9415, 17857, 9415, 12391, 20634, 12281,
  19039, 24055, 16656, 12305, 19384, 25412, 10616, 17541, 9415, 9415, 13108, 12390, 14132, 12325, 19039, 19039, 16069,
  19384, 19384, 16211, 11105, 17365, 9415, 20507, 11088, 25231, 14422, 19384, 17386, 24818, 9415, 24227, 19033, 19039,
  21575, 12309, 9415, 22887, 19030, 19039, 19384, 10713, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566,
  16862, 21571, 10588, 23725, 17414, 17402, 25467, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 8989, 8983, 17430, 17446, 17462, 17473,
  17489, 17502, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449,
  10417, 13079, 9415, 15625, 13227, 17370, 12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213,
  12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 9415, 9415, 9415, 9415,
  12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384,
  13485, 24818, 24626, 24227, 19033, 19039, 21575, 12309, 25931, 17518, 19030, 19039, 19384, 21918, 17557, 17597, 20538,
  21918, 17631, 17660, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 15473, 17688, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415,
  9415, 9415, 8972, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 21888, 9415, 13023, 17737, 12389, 19414, 9415,
  12265, 17766, 17755, 25264, 16074, 10417, 17784, 11382, 15625, 9041, 9415, 12386, 14008, 8990, 12194, 19039, 21851,
  17820, 19384, 26054, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384,
  19384, 10616, 17856, 9415, 9415, 9415, 12390, 19367, 10759, 19039, 19039, 15528, 19384, 19384, 23342, 9415, 9415,
  9415, 20631, 19038, 19039, 19112, 19384, 24798, 24818, 17873, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030,
  19039, 19384, 21918, 24228, 19039, 21574, 21918, 17890, 19442, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569,
  13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125,
  9093, 9415, 9433, 17906, 9415, 17930, 17952, 17970, 17999, 12513, 18015, 18030, 18046, 18059, 9415, 26941, 9415, 9990,
  9415, 13023, 16222, 12169, 20636, 18075, 18093, 18129, 21825, 25753, 14449, 10417, 13079, 9415, 15625, 20066, 9415,
  12386, 24596, 18151, 18167, 18190, 18214, 18236, 18275, 19384, 18306, 18322, 18381, 18416, 23497, 18450, 12391, 18490,
  12281, 19039, 26283, 16656, 12305, 19384, 14657, 18514, 9415, 9415, 11640, 18560, 12390, 19367, 19037, 19039, 22222,
  15710, 19384, 19384, 24154, 19220, 26186, 18577, 20631, 19038, 19039, 18622, 15671, 13485, 17713, 18646, 15497, 18664,
  18706, 18730, 21452, 18774, 12603, 18792, 18606, 20610, 20931, 26768, 19039, 21574, 15181, 10821, 10466, 10590, 10469,
  18822, 18838, 21571, 10588, 16038, 18861, 13570, 21951, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 11125, 10490, 9415, 9415, 20444, 9415, 9415, 9165, 9159, 18887, 18926, 18942,
  18953, 18969, 18982, 9415, 26941, 9678, 17914, 16460, 18998, 9415, 19020, 14776, 9415, 14782, 21413, 25961, 22953,
  14449, 12343, 13363, 9415, 15836, 24692, 12351, 9686, 13135, 8990, 19056, 19082, 19136, 22139, 19162, 23283, 15153,
  12213, 19197, 20400, 19219, 9415, 19236, 20634, 19258, 25351, 19039, 16656, 19274, 22407, 19384, 10616, 19310, 9415,
  21332, 24542, 12390, 19328, 19037, 26616, 19039, 13480, 19957, 22450, 24808, 20465, 9415, 9415, 19363, 25596, 19039,
  17607, 19383, 13485, 10685, 19619, 19401, 14715, 19039, 19436, 12309, 13524, 27304, 19030, 19039, 19384, 21918, 19458,
  19039, 19496, 19515, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 26793, 19536, 19576, 19602, 14852, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 19618, 9415, 9415, 26965,
  9415, 9415, 9415, 26959, 19635, 10249, 19651, 19662, 19678, 19691, 9415, 26941, 20886, 17914, 9415, 13023, 9415,
  19707, 16325, 9415, 20891, 22129, 17644, 19733, 19777, 10417, 13079, 13932, 15625, 22312, 9415, 12386, 14008, 8990,
  12194, 27105, 22525, 22139, 19793, 18529, 16000, 12213, 19812, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039,
  19850, 19889, 19918, 19384, 10616, 9415, 22488, 18776, 11910, 12390, 19367, 15756, 19039, 18198, 13480, 19954, 23718,
  24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309,
  25691, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 19973, 19120, 21566, 16862, 21571,
  10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 11125, 10845, 9415, 9415, 20031, 20004, 9415, 20022, 10993, 20055, 12998, 20091, 20102, 20118, 20131,
  9415, 20147, 12806, 20039, 20172, 13023, 22303, 20206, 20244, 23528, 20260, 20301, 16403, 20317, 20353, 10417, 13079,
  20369, 20387, 13227, 20422, 12386, 14008, 19420, 12194, 19039, 19560, 20662, 17349, 19384, 16000, 12213, 20460, 11652,
  9415, 20481, 20500, 20634, 20523, 19039, 19039, 16656, 20596, 19384, 19384, 10616, 27299, 9415, 9415, 21796, 20626,
  13276, 20652, 19347, 20678, 16031, 19384, 20696, 24808, 11960, 20725, 14317, 24907, 18259, 19097, 19146, 20760, 20786,
  21922, 20805, 20835, 10556, 25237, 20857, 12309, 9132, 26323, 26034, 20907, 20953, 16163, 9380, 21001, 23403, 21050,
  21017, 21043, 21610, 23434, 17112, 15746, 21066, 10588, 23725, 16966, 21082, 19902, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 21156, 9415, 11109, 15221,
  24720, 21180, 21216, 21232, 21243, 21259, 21272, 20156, 21288, 21328, 17914, 9415, 14750, 21348, 21360, 21376, 12540,
  10874, 21398, 25525, 21437, 21495, 10417, 13079, 9415, 15625, 24321, 25803, 12386, 21511, 8990, 12194, 21532, 21560,
  21591, 19499, 17615, 18544, 21626, 12262, 14268, 19520, 17874, 12391, 22756, 12281, 15001, 15023, 16656, 12305, 21685,
  19384, 21665, 9415, 20937, 21701, 9415, 12390, 19367, 19037, 21719, 19039, 13480, 22398, 19384, 24808, 9415, 20190,
  21737, 20631, 19038, 19039, 17607, 19384, 13485, 24818, 21755, 24227, 19470, 12197, 21776, 12309, 21792, 22887, 21812,
  19039, 21680, 21918, 24228, 19039, 21574, 12933, 21841, 21873, 18845, 21914, 21938, 21967, 21571, 10588, 23725, 21094,
  21993, 20709, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125,
  11718, 9415, 9415, 20444, 9415, 9415, 22032, 19873, 22069, 9941, 22045, 19761, 22085, 22098, 9415, 26941, 11027,
  17914, 9415, 13023, 9415, 12389, 20636, 9415, 22114, 19039, 10585, 15992, 14449, 10417, 13079, 22155, 15625, 13227,
  22179, 25878, 14008, 12246, 22198, 22246, 22256, 26123, 22416, 19384, 22272, 22288, 12262, 9415, 9415, 9415, 12391,
  20634, 12281, 19039, 22328, 13052, 12305, 19384, 15782, 10616, 9415, 9415, 25822, 23161, 24177, 12178, 18871, 22354,
  19039, 13480, 23708, 19384, 24808, 25000, 9415, 9415, 20631, 21857, 19039, 22380, 18113, 13485, 24818, 9415, 24227,
  19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 11071, 22432,
  16512, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415,
  15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 11877, 11199, 22475, 11205, 22515, 22504, 24948,
  16423, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 22139, 19384, 19384, 16000,
  12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 9415, 9415,
  9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039,
  17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228,
  14197, 22005, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 15398,
  10426, 10425, 16180, 9415, 22541, 22608, 22597, 22624, 22640, 22653, 9732, 22669, 11149, 22702, 9897, 22728, 21641,
  22744, 22772, 9468, 22799, 21140, 19550, 22838, 22854, 22870, 13079, 9415, 16279, 17983, 22886, 22903, 22923, 8990,
  12194, 22942, 14402, 22139, 20337, 22822, 16000, 22969, 12262, 9415, 20738, 25816, 23005, 23799, 12281, 14392, 12289,
  16656, 23029, 16129, 26813, 23052, 23090, 15631, 23113, 9415, 22907, 23147, 19037, 23199, 23211, 15662, 16135, 19289,
  23237, 26697, 9415, 19004, 20631, 23253, 23299, 19066, 19384, 23332, 20978, 15430, 24227, 19033, 11499, 21575, 26835,
  9415, 22887, 11489, 19039, 23358, 19174, 24228, 19039, 21574, 21918, 10821, 10466, 23375, 24973, 21566, 16835, 22441,
  27065, 23725, 13569, 23391, 23419, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 11125, 23468, 9415, 9415, 17840, 11764, 9415, 26376, 23486, 23513, 23563, 23579, 23590, 23606, 23619,
  9415, 12228, 9415, 17914, 9415, 23635, 13952, 22556, 13978, 13985, 23658, 16552, 16542, 23698, 23741, 23757, 13640,
  18427, 15625, 13227, 9415, 23784, 20219, 23823, 23839, 16762, 22338, 22139, 23879, 23902, 16000, 23919, 23955, 18077,
  23978, 9415, 12391, 12830, 12281, 19039, 19039, 16656, 12305, 19384, 19384, 10616, 9415, 10732, 23997, 24385, 12390,
  24015, 24045, 11509, 10825, 24078, 10528, 16599, 24808, 9415, 24100, 9415, 25102, 18220, 19039, 24119, 24084, 24144,
  14313, 27189, 24170, 19033, 13336, 24193, 19747, 9415, 24223, 19030, 19039, 19384, 14067, 24244, 24062, 21574, 24306,
  10821, 10466, 16996, 24358, 21566, 22016, 16562, 26159, 16611, 20275, 13570, 14852, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 24382, 9415, 9415, 13029, 9415, 9415, 12465,
  12852, 24401, 13290, 24436, 24451, 24467, 24480, 13910, 11627, 15249, 24496, 23547, 24531, 24565, 24582, 24612, 24619,
  20744, 14160, 18679, 24642, 24658, 24674, 24708, 20580, 18337, 13227, 12625, 23934, 22569, 25992, 24742, 17581, 14412,
  21027, 24769, 24786, 16000, 12213, 24836, 9415, 24872, 23981, 24892, 23013, 24937, 21106, 19039, 21544, 24964, 18745,
  19796, 10616, 24997, 25016, 25035, 25059, 25093, 25118, 20285, 21721, 14963, 14615, 14876, 15679, 24808, 25070, 19312,
  25153, 25173, 25208, 25253, 14725, 24207, 26096, 25280, 9415, 25327, 17569, 23851, 25376, 16373, 10936, 22887, 19717,
  21421, 25405, 25428, 16734, 16772, 25454, 25483, 25511, 25541, 10590, 10469, 21566, 16862, 21571, 25569, 18630, 25585,
  13570, 18758, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125,
  9415, 9415, 9415, 20444, 9415, 9415, 9460, 9415, 8972, 15102, 25622, 25633, 25649, 25662, 9415, 26941, 9415, 17914,
  25678, 13023, 9415, 12389, 20636, 9415, 12265, 19039, 18806, 16638, 14449, 10417, 13390, 9415, 15625, 13227, 25717,
  11660, 14008, 8990, 25742, 19039, 21129, 22139, 25769, 19384, 22459, 25788, 12262, 25838, 9415, 25858, 25894, 25923,
  12281, 25947, 21118, 25977, 12305, 26008, 22389, 10616, 9415, 24412, 9415, 9415, 26024, 19367, 21977, 19039, 19039,
  13480, 26050, 19384, 24808, 26070, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24366, 20006, 24227, 19033,
  18714, 26091, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 26112, 23067, 10590, 10469,
  21566, 16862, 21571, 16867, 23682, 13569, 21479, 26139, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 22989, 9415, 15123, 26175, 10070, 26202,
  24921, 26227, 26240, 9415, 26941, 9415, 17914, 9415, 13023, 9415, 12389, 20636, 9415, 12265, 14381, 14370, 18690,
  14449, 10417, 13079, 9415, 15625, 13227, 9415, 17721, 14008, 26256, 26272, 19039, 21851, 22139, 26299, 19384, 16000,
  12213, 12262, 9415, 9755, 9415, 23939, 12952, 12281, 14942, 19039, 16656, 12305, 16569, 19384, 20770, 9415, 9415,
  9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038, 19039,
  17607, 19384, 13485, 13519, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228,
  19039, 21574, 20869, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 26672,
  9415, 9415, 26320, 10805, 26339, 26403, 26392, 26419, 26435, 26448, 9415, 26941, 9415, 17914, 9415, 13023, 9415,
  12389, 20636, 9415, 12265, 19039, 10585, 23673, 17033, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990,
  12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039,
  16656, 12305, 19384, 19384, 10616, 9415, 9415, 9166, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384,
  24808, 9415, 26464, 9415, 20631, 27071, 19039, 10644, 10654, 24128, 24818, 9415, 24227, 19033, 19039, 21575, 12309,
  9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571,
  10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 12407, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972, 9941, 9415, 20819, 26484, 26497, 9415,
  26941, 9415, 21164, 9415, 13023, 9415, 11479, 20636, 26513, 26522, 17073, 17062, 24753, 14449, 10417, 13079, 9415,
  15625, 26538, 9415, 12386, 14008, 8990, 12194, 19039, 21851, 20919, 19384, 19384, 26554, 26570, 26586, 9415, 9415,
  9415, 12391, 20634, 26605, 19039, 19039, 17768, 26632, 19384, 19384, 14496, 9415, 9415, 9415, 9415, 12390, 19367,
  19037, 19039, 19039, 13480, 19384, 19384, 24808, 14341, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24818,
  9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821,
  10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972,
  9941, 9415, 15460, 16956, 14248, 9415, 27135, 9415, 17914, 9415, 20075, 9415, 12389, 20636, 9415, 12265, 19039, 22211,
  16363, 13430, 26652, 13079, 9415, 26688, 13227, 9415, 12386, 22926, 8990, 12194, 19039, 26721, 22139, 19384, 19384,
  26743, 12213, 26759, 27268, 9415, 9415, 12391, 26784, 12281, 13152, 19039, 16656, 12305, 19384, 26809, 10616, 9415,
  23807, 9415, 9415, 11188, 19367, 19586, 19039, 10765, 13480, 26829, 19384, 24808, 9415, 9415, 9415, 20631, 19038,
  18174, 25606, 19384, 10661, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 26851, 25043, 19030, 25220, 24770, 21918,
  24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 11125, 9415, 9415, 9415,
  20444, 9415, 9415, 9415, 9415, 26870, 9941, 9415, 15460, 16956, 14248, 9415, 26941, 9415, 17914, 9415, 13023, 9415,
  12389, 20636, 9415, 12265, 19039, 10585, 15992, 14449, 10417, 13079, 9415, 15625, 13227, 9415, 12386, 14008, 8990,
  12194, 19039, 21851, 22139, 19384, 19384, 16000, 12213, 12262, 9415, 9415, 9415, 12391, 20634, 12281, 19039, 19039,
  16656, 12305, 19384, 19384, 10616, 9415, 9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384,
  24808, 9415, 9415, 9415, 20631, 19038, 19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309,
  9415, 22887, 19030, 19039, 19384, 21918, 24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571,
  10588, 23725, 13569, 13570, 14852, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 8929, 26988, 9415, 9415, 10446, 26886, 26911, 26927, 26981, 27008, 26895, 9415, 27052, 27087, 27121, 9415,
  26941, 9415, 17914, 9415, 18589, 9415, 9415, 9415, 9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415,
  9415, 9415, 20444, 9415, 9415, 24420, 9415, 8972, 25077, 27151, 27162, 9415, 22712, 9415, 26941, 9415, 17914, 9415,
  9415, 9415, 9415, 9415, 9318, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 13111, 9415,
  9415, 9415, 9415, 27178, 27212, 27239, 27250, 9415, 27223, 9415, 26941, 9415, 17914, 9415, 24506, 9415, 9415, 9415,
  9415, 11783, 9415, 9415, 9585, 9773, 8949, 9415, 9415, 15625, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 8929, 9415, 9415, 9415, 20444, 9415, 9415, 9415, 9415, 8972,
  9415, 9415, 9415, 9415, 16299, 9415, 26941, 9415, 17914, 9415, 9415, 9415, 12389, 20636, 9415, 12265, 19039, 10585,
  15992, 14449, 10417, 9415, 9415, 15625, 9415, 9415, 12386, 14008, 9415, 19036, 19039, 21851, 13316, 19384, 19384,
  13488, 24816, 9415, 9415, 9415, 9415, 12391, 20634, 18598, 19039, 19039, 12327, 10462, 19384, 19384, 13490, 9415,
  9415, 9415, 9415, 12390, 19367, 19037, 19039, 19039, 13480, 19384, 19384, 24808, 9415, 9415, 9415, 20631, 19038,
  19039, 17607, 19384, 13485, 24818, 9415, 24227, 19033, 19039, 21575, 12309, 9415, 22887, 19030, 19039, 19384, 21918,
  24228, 19039, 21574, 21918, 10821, 10466, 10590, 10469, 21566, 16862, 21571, 10588, 23725, 13569, 13570, 14852, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 21703, 9415, 9415,
  9415, 27267, 9415, 9415, 9415, 27266, 27284, 27320, 27331, 21702, 27347, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415,
  9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 9415, 0, 0, 0, 0, 49403, 49403, 49403, 49403, 51452, 0, 0,
  0, 0, 0, 51452, 51452, 36864, 38912, 51452, 51452, 51452, 51452, 51452, 51452, 34816, 51452, 51452, 51452, 51452,
  51452, 0, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 49403,
  49403, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452,
  296, 49403, 51452, 49403, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 0, 51452, 51452, 51452,
  51452, 51452, 51452, 51452, 0, 0, 0, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 51452, 1, 8194, 3,
  4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 137216, 137216, 137216, 0, 482, 483, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  277, 278, 0, 0, 0, 0, 0, 0, 0, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 310, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 853, 55671, 375, 55671, 375, 375, 375, 375, 55671, 375, 375, 375, 375, 55671, 55671, 55671,
  55671, 375, 55671, 55671, 375, 0, 55671, 55671, 55671, 55671, 55671, 55671, 55671, 0, 0, 0, 0, 0, 454, 682, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 795, 0, 0, 0, 0, 559, 0, 0, 0, 568, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83968, 83968, 734,
  482, 483, 0, 0, 734, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 299, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 257, 0, 0, 0, 0, 264,
  59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88064, 88064, 0, 261, 261, 264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 245760, 0, 0, 0, 0, 59717, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 311, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1217, 414, 414, 0, 454, 414, 454, 414, 414, 414, 414, 414, 414, 479, 482, 482, 482, 482, 482, 482, 482,
  414, 414, 482, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 18934, 262, 0, 27130, 265, 0, 0, 0,
  0, 0, 0, 0, 261, 0, 262, 0, 264, 0, 265, 0, 0, 0, 0, 0, 0, 30720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0,
  0, 27359, 483, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 455, 0, 0, 0, 0, 0, 0, 530667, 8194, 3, 4, 0, 241, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 339968, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 417792, 0, 0, 0,
  0, 61440, 0, 61440, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0,
  61440, 61440, 61440, 61440, 61440, 61440, 61440, 0, 0, 0, 0, 0, 491, 492, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1603, 45414,
  182630, 46660, 45414, 45414, 0, 0, 73728, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 267, 267, 854, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 268, 974, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0, 0, 36864, 38912, 65536,
  0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 314, 0, 0, 0, 0, 0, 0, 0, 0, 0, 315392, 615, 0, 0, 0, 0, 0, 0, 65536, 65536,
  65536, 65536, 65536, 65536, 65536, 0, 0, 65536, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 36864, 38912, 0, 67584, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0,
  482, 0, 0, 0, 67584, 0, 0, 0, 0, 67584, 0, 0, 0, 0, 0, 0, 0, 0, 253, 0, 0, 0, 0, 0, 253, 253, 0, 0, 326, 326, 0, 0, 0,
  0, 0, 0, 326, 0, 0, 0, 0, 0, 0, 454, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 736, 737, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 684, 0, 265, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  98304, 0, 0, 262, 262, 265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 309248, 0, 0, 0, 0, 36864, 69961, 0, 0, 0, 0, 0, 0,
  34816, 0, 0, 0, 0, 0, 0, 518, 519, 0, 0, 0, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45878, 45414, 45414, 45414, 45414,
  415, 415, 0, 455, 415, 455, 415, 415, 415, 415, 415, 415, 480, 483, 483, 483, 483, 483, 483, 483, 415, 415, 483, 1,
  8194, 3, 4, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 495, 0, 0, 0, 0, 0, 0, 0, 482, 27362, 0, 0, 0, 4, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1022, 0, 0, 1025, 0, 0, 0, 0, 483, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 479, 480, 482, 483, 253, 253,
  0, 0, 253, 253, 71933, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 297, 253, 253,
  253, 0, 71933, 253, 253, 253, 253, 301, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253,
  71933, 253, 253, 253, 253, 253, 36864, 38912, 253, 253, 253, 253, 253, 253, 34816, 253, 253, 253, 253, 253, 0, 253,
  253, 253, 71933, 253, 253, 253, 71933, 253, 71933, 71933, 253, 71933, 253, 253, 253, 253, 71933, 253, 253, 253, 253,
  253, 253, 253, 71933, 71933, 71933, 0, 71933, 71933, 71933, 71933, 71933, 71933, 71933, 0, 0, 0, 0, 0, 545, 0, 0, 548,
  0, 0, 0, 0, 553, 0, 0, 0, 253, 0, 253, 253, 71933, 253, 253, 71933, 71933, 71933, 71933, 71680, 71933, 71981, 71981,
  71981, 71981, 71981, 71981, 71981, 71933, 71933, 71933, 1, 8194, 3, 4, 0, 0, 0, 0, 0, 45414, 45414, 0, 45414, 0, 0,
  45414, 45414, 0, 0, 45414, 0, 0, 0, 0, 578069, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 77824, 36864,
  38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 532, 296, 296, 296, 0, 0, 0, 0, 0, 0, 0, 141312, 141312, 0, 1, 8194,
  3, 4, 0, 0, 0, 0, 77824, 77824, 77824, 0, 0, 77824, 0, 0, 77824, 77824, 0, 0, 77824, 0, 77824, 77824, 77824, 77824, 0,
  77824, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 77824, 77824, 77824, 77824, 77824, 77824, 77824, 0, 0, 0,
  77824, 0, 0, 0, 0, 77824, 0, 77824, 77824, 77824, 0, 8194, 3, 4, 0, 0, 0, 0, 0, 45414, 45414, 0, 45414, 0, 0, 45414,
  45414, 307, 0, 45414, 63488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 298, 79872, 0, 79872, 79872, 79872, 79872,
  79872, 79872, 79872, 79872, 79872, 81920, 79872, 79872, 79872, 79872, 81920, 79872, 79872, 81920, 0, 79872, 79872,
  79872, 79872, 79872, 79872, 79872, 0, 0, 14792, 0, 0, 0, 14792, 0, 14792, 0, 79872, 0, 0, 0, 79872, 0, 14792, 14792,
  14792, 14792, 14792, 14792, 14792, 79872, 79872, 14792, 1, 8194, 3, 4, 0, 0, 83968, 83968, 83968, 83968, 83968, 83968,
  83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 1, 8194, 3, 4, 0, 0, 83968, 83968, 83968, 83968,
  83968, 0, 83968, 83968, 83968, 83968, 83968, 83968, 83968, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8194,
  3, 4, 0, 0, 0, 86016, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 86016, 86016, 0, 86016, 0, 0, 0, 0, 261, 262, 0, 264,
  265, 0, 0, 0, 0, 510, 0, 0, 0, 0, 0, 45423, 45423, 0, 45423, 391, 0, 45423, 45423, 391, 0, 45423, 86016, 86016, 86016,
  86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 86016, 0, 0, 86016, 0, 86016,
  86016, 0, 0, 86016, 86016, 0, 86016, 86016, 86016, 86016, 86016, 0, 86016, 86016, 86016, 86016, 86016, 86016, 86016,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 1, 236, 3, 4, 0, 0, 0, 0, 0, 243, 0, 0, 0, 0, 0, 0, 0, 77824, 0, 0,
  77824, 77824, 0, 0, 0, 0, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064, 88064,
  88064, 88064, 88064, 1, 0, 3, 4, 41199, 41199, 88064, 88064, 88064, 88064, 88064, 0, 88064, 88064, 88064, 88064,
  88064, 88064, 88064, 0, 0, 0, 0, 0, 570, 0, 0, 0, 0, 576, 0, 0, 0, 581, 0, 0, 0, 489, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 143360, 0, 0, 482, 483, 0, 47561, 0, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  745, 746, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 411648, 0, 296, 0, 0, 0, 15252, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1194, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 256, 0, 0, 0, 0, 0, 1230, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  45893, 45414, 45414, 45414, 48607, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48413, 47561, 0, 0, 0, 1599, 0, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 48591, 47520, 47520, 48709, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 48714, 47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47561, 47520, 47520, 47520, 48721, 47561, 47561, 47561, 47561, 47561, 48724, 47561, 47561,
  47561, 47561, 47561, 47561, 47520, 0, 969, 0, 971, 0, 973, 0, 975, 47561, 0, 0, 0, 45414, 47520, 47520, 47520, 48744,
  48745, 47520, 47520, 48748, 47520, 47520, 47520, 47520, 47520, 48514, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 48527, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 408009, 47520, 0, 0, 0, 0,
  48781, 47561, 47561, 47561, 47561, 47561, 48787, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1447, 0, 0, 0, 0, 0,
  48797, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48807, 47561, 47561, 47561, 47561, 47561, 0, 0,
  0, 0, 0, 0, 1595, 0, 0, 0, 0, 0, 0, 1532, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1198, 0, 0, 0, 0, 0, 0, 47561, 48853, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 47520, 47520, 47520, 178592, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 222464, 47520, 47520, 47520, 47520, 47520, 92644, 92644, 92644, 92644, 92644,
  92644, 92644, 0, 0, 92644, 1, 8194, 3, 4, 41199, 41199, 0, 482, 483, 94208, 47561, 0, 4, 41199, 0, 0, 0, 0, 0, 0, 0,
  0, 294, 0, 0, 0, 0, 294, 294, 0, 0, 0, 0, 45414, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 48386, 47520, 47520, 47520, 0, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 258, 259, 0, 0, 96639, 0,
  96639, 96639, 0, 0, 96639, 96639, 96639, 96639, 96639, 96639, 96639, 0, 0, 0, 0, 0, 619, 0, 0, 569, 569, 0, 0, 0, 414,
  415, 47520, 0, 0, 254, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96639, 96639, 0, 96639, 0, 0, 0, 0, 96639, 0, 0, 0, 0, 96639,
  96639, 96639, 96639, 96639, 96639, 96639, 96639, 96639, 0, 1, 8194, 3, 4, 0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 249856, 0, 20743, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 497, 20780, 20780, 20780, 20780,
  20780, 20780, 20780, 0, 0, 20780, 1, 8194, 3, 4, 41199, 41199, 0, 482, 483, 23063, 47561, 0, 4, 41199, 0, 0, 0, 0, 0,
  0, 0, 0, 312, 0, 0, 0, 0, 312, 312, 0, 0, 0, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 984, 0, 986, 0, 988, 0, 990, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 1071, 0, 1073, 0, 47960, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 48206, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 1124, 0, 15252, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 0, 1658, 0, 1660, 1073, 1249, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48509, 1185, 1186, 1187, 1188, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 308, 0, 0, 0, 1, 8194, 3, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 261, 0, 0, 0, 0, 0, 0,
  267, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 525, 266, 267, 0, 266, 267, 0, 0, 266, 0, 0, 0, 266, 0, 0, 0, 0, 0,
  0, 1539, 0, 0, 0, 1542, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 221542, 45414, 45414, 45414, 45414,
  45414, 45414, 0, 0, 0, 229376, 0, 0, 0, 0, 0, 0, 0, 229376, 0, 414, 415, 47520, 627, 627, 627, 0, 0, 0, 0, 0, 0, 0,
  627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 627, 0, 482, 483, 0, 684, 0, 4, 41199, 0,
  0, 0, 0, 0, 0, 0, 0, 479, 0, 480, 0, 482, 0, 483, 0, 0, 0, 0, 0, 0, 0, 0, 851, 0, 627, 627, 627, 627, 627, 627, 627,
  627, 627, 627, 627, 627, 627, 627, 0, 0, 627, 627, 627, 627, 627, 627, 0, 627, 627, 627, 627, 627, 627, 627, 627, 627,
  627, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 627, 627, 627, 627, 627, 627, 911, 0, 0,
  911, 0, 0, 684, 684, 684, 684, 684, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 684, 684, 684, 684, 684, 684,
  684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 627, 479, 480, 0, 911, 684, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 773, 627, 0, 0, 0, 0, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 627, 627, 627, 627, 627, 627,
  0, 0, 684, 684, 684, 684, 684, 684, 684, 684, 684, 0, 0, 0, 0, 627, 627, 627, 684, 684, 684, 684, 684, 684, 684, 684,
  684, 684, 684, 627, 0, 0, 0, 0, 0, 0, 0, 0, 684, 0, 0, 0, 0, 0, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684, 684,
  684, 627, 684, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45650, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0,
  151057, 47520, 47520, 47520, 47520, 47520, 47520, 48599, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 48368, 47520, 47520, 47520, 47520, 47520, 48374, 47520, 47520, 47520, 684, 684, 684, 684, 684, 684, 684, 684,
  684, 684, 684, 684, 0, 0, 0, 0, 0, 0, 0, 627, 627, 627, 684, 684, 684, 684, 684, 684, 0, 0, 0, 627, 627, 627, 627,
  684, 684, 684, 684, 0, 627, 627, 684, 684, 627, 684, 627, 684, 627, 684, 627, 684, 684, 684, 684, 684, 0, 0, 0, 0, 0,
  0, 0, 627, 627, 627, 627, 627, 454, 455, 683, 684, 684, 684, 684, 684, 684, 684, 684, 627, 851, 0, 0, 851, 0, 911, 0,
  108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 108544, 0, 0, 0, 0, 261, 262, 0, 264, 265, 0, 0, 0, 159744, 0, 0,
  0, 0, 0, 1209, 0, 0, 0, 0, 0, 1213, 0, 0, 0, 0, 0, 0, 376832, 401408, 0, 0, 0, 0, 0, 0, 0, 0, 45414, 45414, 45414,
  45879, 45414, 45414, 45414, 45414, 0, 108544, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 108544, 0, 0, 108544,
  108544, 108544, 1, 8194, 3, 4, 0, 0, 0, 0, 108544, 108544, 108544, 0, 0, 108544, 0, 108544, 108544, 0, 0, 108544,
  108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 0, 0, 108544, 108544, 108544, 108544, 108544, 108544, 108544,
  108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 108544, 0, 108544, 108544, 108544, 108544, 108544,
  108544, 108544, 0, 0, 0, 264, 0, 265, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 302, 0, 0, 0, 0, 43008, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 414, 415, 0, 0, 454, 0, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 261, 262, 264, 265, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 480, 0, 0, 0, 110968, 110968, 110968, 110968, 110968, 110968, 110968, 110968, 110968,
  110968, 110968, 110968, 110968, 110968, 110968, 110968, 0, 110968, 110968, 110968, 110968, 110968, 110968, 110968, 0,
  0, 0, 111073, 111073, 111073, 111073, 111073, 111073, 111073, 110968, 110968, 111078, 1, 8194, 3, 4, 0, 0, 0, 0, 0,
  45414, 45414, 45414, 45414, 229734, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 47520, 47520, 47520, 47520,
  48660, 47520, 47520, 0, 482, 483, 0, 0, 118784, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1223, 0, 0, 0, 0, 0, 1228, 124928,
  124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 124928,
  124928, 0, 124928, 124928, 124928, 124928, 124928, 124928, 124928, 0, 0, 0, 0, 482, 483, 0, 0, 120832, 4, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1339, 0, 0, 1342, 0, 313344, 0, 127353, 127353, 127353, 127353, 127353, 127353, 127353, 127353, 127353,
  127353, 127353, 127353, 127353, 127353, 127353, 127353, 0, 127353, 127353, 127353, 127353, 127353, 127353, 127353, 0,
  0, 0, 0, 0, 0, 135168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100352, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45645, 45414, 45414,
  248166, 45414, 281175, 45414, 299366, 0, 482, 483, 0, 0, 0, 0, 0, 90112, 145408, 0, 0, 0, 0, 0, 0, 0, 110968, 0,
  110968, 110968, 0, 0, 110968, 110968, 0, 0, 133120, 0, 0, 133120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0,
  0, 0, 133120, 0, 0, 0, 133120, 0, 0, 0, 0, 1, 8194, 534765, 4, 0, 0, 0, 0, 0, 0, 0, 0, 244, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 415, 627, 122880, 482, 483, 0, 0, 122880, 4, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 1351, 1352, 1353, 0, 0, 0, 0, 137216, 137216, 137216, 137216, 137216, 137216, 137216, 0, 0, 137216, 1, 8194,
  3, 4, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45646, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 1245, 0, 0, 0, 0,
  17454, 0, 0, 855, 0, 47960, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  48604, 47520, 47520, 975, 0, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 749, 0, 751, 0, 0, 0, 0, 261, 262, 0, 264, 265, 0, 0,
  155648, 0, 0, 0, 0, 0, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 761, 0, 0, 0, 0, 853, 753, 0, 755, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 414, 415, 47520, 0, 0, 17454, 0, 853, 0, 855, 47960, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 48207, 47520, 47520, 48210, 47520, 48212, 47520, 48214, 913, 0, 915, 15252, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 47561, 0, 0, 0, 1249, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 0, 0, 482, 483, 0, 47561, 0, 4, 239, 0, 0, 0, 0, 0,
  0, 0, 0, 758, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 342, 1462, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 1, 8194, 3,
  4, 41200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 265, 0, 0, 0, 0, 0, 0, 141312, 0, 141312, 0, 0, 0, 0, 141312, 0, 0, 0, 0,
  0, 141312, 141312, 141312, 0, 141312, 141312, 0, 0, 141312, 141312, 141312, 141312, 141312, 141312, 141312, 0, 0, 0,
  0, 0, 679, 455, 0, 0, 0, 0, 0, 0, 0, 0, 0, 317, 0, 0, 0, 0, 317, 0, 0, 114688, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 554, 0, 1, 8194, 3, 238, 0, 0, 0, 0, 0, 0, 0, 0, 0, 245, 0, 0, 0, 0, 0, 45421, 45421, 380, 45421, 389, 380, 45421,
  45421, 389, 380, 45421, 0, 143360, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 614, 0, 0, 378880, 0, 0,
  0, 378880, 617, 514, 0, 0, 143360, 143360, 143360, 0, 0, 143360, 0, 0, 143360, 0, 0, 0, 143360, 0, 143360, 143360,
  143360, 143360, 0, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 143360, 0, 143360, 143360, 143360, 143360,
  143360, 143360, 143360, 0, 0, 0, 0, 482, 483, 0, 0, 0, 1061351, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1541, 0, 0, 0, 0, 1546,
  45414, 0, 269, 0, 268, 268, 269, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814, 268, 0, 268, 320, 268, 0, 0, 0, 0,
  0, 0, 0, 324, 269, 269, 0, 0, 0, 0, 261, 262, 0, 264, 265, 0, 106496, 0, 0, 0, 0, 0, 0, 571, 0, 0, 0, 577, 578, 0,
  580, 0, 582, 0, 0, 36864, 38912, 269, 0, 268, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 748, 750, 0, 0, 752, 754, 0, 0, 0, 0,
  0, 349, 349, 349, 357, 45415, 45415, 357, 45415, 384, 357, 45415, 45415, 384, 357, 45415, 384, 357, 384, 357, 357,
  357, 357, 384, 357, 357, 357, 357, 357, 357, 357, 357, 411, 357, 357, 411, 47521, 357, 357, 357, 45415, 357, 45415,
  438, 47547, 47547, 47562, 47547, 47547, 47547, 47562, 47547, 47562, 47547, 47547, 47547, 47547, 47547, 47547, 47547,
  47562, 47562, 47562, 47562, 47562, 47562, 47562, 47547, 47547, 47562, 1, 8194, 3, 4, 41199, 41199, 0, 0, 557, 0, 0,
  559, 0, 0, 0, 560, 0, 0, 510, 0, 0, 0, 0, 0, 680, 681, 0, 0, 0, 0, 0, 0, 0, 0, 0, 521, 264192, 0, 0, 0, 0, 0, 0, 537,
  491, 0, 0, 45414, 45414, 45643, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 0, 995,
  45414, 45414, 45660, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 317, 0, 0, 0, 0, 0, 609, 0, 0, 0, 0, 0, 0,
  523, 0, 0, 0, 0, 0, 0, 0, 609, 0, 0, 620, 621, 0, 0, 0, 414, 415, 47520, 47764, 47520, 47520, 537, 0, 0, 0, 560, 537,
  0, 47520, 47520, 47734, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47752, 47520, 47755, 47520, 47758, 47520,
  47520, 47520, 47776, 47755, 47758, 47520, 454, 455, 0, 47561, 47561, 47561, 47793, 47561, 47561, 47561, 47561, 47561,
  0, 0, 0, 0, 0, 1633, 0, 0, 0, 0, 0, 0, 819, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 258048,
  0, 0, 0, 0, 0, 47561, 47561, 47561, 47813, 47561, 47817, 47561, 47820, 47561, 47561, 47830, 47561, 47561, 47755, 479,
  480, 0, 482, 483, 0, 47817, 0, 4, 41199, 0, 0, 0, 0, 0, 743, 0, 0, 0, 0, 0, 45424, 45424, 382, 45424, 392, 382, 45424,
  45424, 382, 382, 45424, 0, 787, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 293, 0, 0, 0,
  0, 296, 47993, 47520, 47520, 47520, 47520, 47520, 819, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  48203, 47520, 47520, 47520, 47520, 17454, 0, 753, 0, 755, 0, 0, 0, 0, 0, 0, 0, 999, 0, 0, 0, 0, 0, 0, 749, 751, 0, 0,
  753, 755, 0, 0, 0, 0, 0, 1015, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1027, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  419840, 296, 0, 0, 0, 45414, 45414, 45414, 45414, 46105, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  45889, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 48187, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 311712, 48215, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 17454, 0, 0, 0, 0, 261, 262, 0, 264, 265, 104448, 0, 0, 0, 0, 0, 0, 0,
  86016, 86016, 86016, 1, 8194, 3, 4, 0, 0, 913, 0, 915, 15252, 47561, 47561, 47561, 48233, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48241, 0, 1191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 1219, 1027, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 414, 626, 0, 0, 0, 0, 0, 45414, 46290, 46291, 45414, 45414, 45414, 45414, 45414, 45414, 46295,
  45414, 45414, 45414, 45414, 45414, 391526, 45414, 0, 0, 0, 0, 0, 391168, 17454, 0, 0, 0, 0, 0, 45428, 45428, 0, 45428,
  394, 0, 45428, 45428, 394, 398, 45428, 0, 1249, 47520, 47520, 48356, 47520, 47520, 48357, 47520, 48358, 47520, 47520,
  47520, 47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 47561, 47561, 47561, 47561, 47520, 47520, 47520, 48365, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48603, 47520, 47520, 48606, 47561, 48428, 0,
  1325, 0, 1326, 0, 1327, 0, 1328, 48433, 0, 0, 0, 0, 0, 0, 749, 751, 0, 0, 753, 755, 0, 0, 0, 758, 1185, 1186, 1187,
  1188, 0, 1335, 0, 0, 0, 0, 1340, 0, 0, 0, 0, 0, 0, 749, 751, 0, 0, 753, 755, 0, 0, 757, 0, 0, 350208, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 1357, 47520, 47520, 47520, 48513, 47520, 47520, 1287, 1288, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47828, 47561, 47561, 47561, 47561, 47520, 479, 480, 0, 0, 1452, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 623, 415, 0, 47520, 48595, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  48605, 47520, 0, 0, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 0, 0, 0,
  0, 0, 0, 0, 0, 47561, 47561, 47561, 48621, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520,
  47561, 0, 0, 0, 1441, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 235520, 0, 0, 0, 0, 47561, 48690, 47561, 47561, 47561, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 279, 280, 281, 282, 0, 1692, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 47520, 47520, 47520, 47520, 47561, 0, 0, 0, 0, 1739, 0,
  1741, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48208, 47520, 47520, 47520, 47520, 47520, 47520,
  0, 270, 271, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 523, 0, 0, 0, 0, 0, 36864, 38912, 0, 0, 0, 333, 333, 0, 34816,
  0, 0, 0, 0, 0, 0, 749, 751, 0, 0, 753, 755, 0, 756, 0, 0, 47548, 47548, 47548, 47563, 47548, 47563, 47548, 47548,
  47548, 47548, 47548, 47548, 47548, 47563, 47563, 47563, 47563, 47563, 47563, 47563, 47548, 47548, 47563, 1, 8194, 3,
  4, 41199, 41199, 0, 0, 1031, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  45414, 45894, 45414, 45896, 0, 0, 1360, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 624, 625, 0, 45414, 46429, 45414,
  45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 1380, 0, 0, 0, 1248, 1249, 47520, 47520, 48489, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47987, 47520, 47520, 47520, 47520, 1, 8194, 3,
  4, 41199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 246, 247, 273, 0, 36864, 38912, 0, 275, 0, 334, 334, 335, 34816, 335, 340, 335,
  340, 0, 0, 0, 0, 261, 262, 20743, 264, 265, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 23063, 20780, 0, 0, 0, 0, 340, 340,
  351, 355, 355, 45416, 45416, 355, 45416, 385, 355, 45416, 45416, 385, 355, 45416, 385, 355, 400, 355, 355, 355, 355,
  406, 355, 409, 410, 409, 410, 410, 410, 410, 355, 410, 410, 355, 47522, 410, 410, 410, 45416, 410, 45416, 410, 47549,
  47549, 47564, 47549, 47549, 47549, 47564, 47549, 47564, 47549, 47549, 47549, 47549, 47549, 47549, 47549, 47564, 47564,
  47564, 47564, 47564, 47564, 47564, 47549, 47549, 47564, 1, 8194, 3, 4, 41199, 41199, 0, 0, 528, 0, 0, 0, 0, 296, 296,
  296, 0, 0, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0, 0, 494, 0, 0, 0, 0, 0, 0, 0, 528, 0, 0, 0, 0, 559, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 768, 0, 0, 0, 0, 0, 0, 0, 0, 762, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 579, 0, 0, 0, 0, 0, 817, 0, 0,
  0, 0, 0, 45414, 45876, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 274432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 67584, 0, 0, 0, 67584, 45414, 45884, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  45414, 45414, 45414, 45414, 45414, 0, 0, 842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 842, 0, 853, 855, 0, 47960, 47961, 47962,
  47520, 47520, 47520, 47968, 47520, 47971, 47520, 47520, 47520, 47520, 47975, 47561, 47561, 47561, 48031, 47561, 48034,
  47561, 47561, 47561, 47561, 48039, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 348160, 0, 975, 0,
  47561, 0, 977, 0, 0, 0, 0, 0, 0, 0, 749, 0, 751, 0, 0, 0, 0, 261, 18937, 0, 264, 27133, 0, 0, 0, 0, 0, 0, 0, 296, 296,
  296, 0, 536, 0, 0, 0, 0, 0, 1044, 0, 45414, 45414, 45414, 45414, 45414, 46106, 45414, 45414, 45414, 45414, 45414,
  45414, 45414, 0, 0, 0, 0, 0, 0, 17454, 0, 1248, 0, 0, 17454, 0, 853, 0, 855, 47960, 47520, 47520, 47520, 48182, 47520,
  47520, 47520, 47520, 47520, 256416, 47520, 287136, 47520, 47520, 47520, 47520, 47520, 47761, 47520, 47520, 47520,
  48188, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 1122,
  47520, 47520, 48202, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48715,
  47520, 47520, 913, 0, 915, 15252, 47561, 47561, 47561, 47561, 47561, 48235, 47561, 47561, 47561, 47561, 47561, 47561,
  47520, 1171, 0, 1173, 0, 1175, 0, 1177, 0, 47561, 48242, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48249,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 47520, 47561, 1, 8194, 3, 4, 41199, 41199, 0, 0, 1027, 1220,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1012, 0, 0, 0, 46532, 45414, 45414, 0, 1480, 0, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 48593, 48619, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47520, 47561, 0, 0, 1440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1368, 0, 0, 1371, 0, 0, 0, 0, 1530, 0, 0, 1533, 0, 0, 0,
  0, 0, 0, 0, 0, 1338, 0, 0, 0, 0, 0, 0, 0, 47520, 48663, 48664, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 48671, 47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 47743, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48191, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 801, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 48000, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 1287, 1288, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48423,
  47561, 47561, 47561, 47561, 47561, 47561, 47520, 47520, 48720, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47520, 479, 480, 47561, 47561, 47561, 48732, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 306, 0, 0, 0, 306, 47520, 48828, 47520, 47520, 47520, 47520, 47561, 47561, 47561, 48835, 47561, 47561, 47561,
  47561, 47561, 47561, 47520, 1172, 969, 1174, 971, 1176, 973, 1178, 975, 47561, 277, 0, 36864, 38912, 0, 0, 0, 305,
  305, 0, 34816, 0, 0, 0, 0, 343, 0, 350, 352, 352, 352, 45417, 45417, 352, 45417, 386, 352, 45417, 45417, 386, 352,
  45417, 386, 352, 386, 402, 402, 402, 402, 407, 402, 402, 402, 402, 402, 402, 402, 402, 47523, 402, 402, 402, 45417,
  402, 45417, 402, 47550, 47550, 47565, 47550, 47550, 47550, 47565, 47550, 47565, 47550, 47550, 47550, 47550, 47550,
  47550, 47550, 47565, 47565, 47565, 47565, 47565, 47565, 47565, 47550, 47550, 47565, 1, 8194, 3, 4, 41199, 41199, 0, 0,
  612, 0, 612, 0, 0, 0, 0, 0, 0, 0, 612, 414, 415, 47520, 0, 0, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 192969, 47561, 0, 1439, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 799, 0, 0, 47747, 47520, 47520, 47520,
  47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48262, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47807, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 479,
  480, 0, 482, 483, 0, 47561, 0, 4, 41199, 0, 0, 0, 0, 742, 0, 0, 0, 0, 0, 763, 0, 0, 45414, 45414, 45414, 45414, 45880,
  45414, 45414, 45414, 1479, 0, 0, 47520, 47520, 48588, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 0, 48515,
  47561, 47561, 47561, 47561, 48519, 47561, 47561, 0, 0, 0, 789, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0,
  511, 563, 564, 0, 227686, 45414, 45414, 45414, 45414, 45414, 45414, 291174, 45414, 45890, 45414, 45414, 45414, 45414,
  45414, 45414, 0, 0, 0, 519, 0, 0, 0, 0, 0, 0, 555, 519, 0, 414, 415, 47520, 855, 0, 47960, 154016, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 227744, 47520, 47520, 47520, 0, 0, 0, 0, 281073, 0, 0, 47520, 47520,
  47520, 47737, 47520, 47520, 248224, 47520, 281222, 47520, 299424, 47520, 47520, 47757, 47759, 47520, 47520, 48009,
  47520, 47520, 47520, 47520, 47520, 0, 913, 915, 0, 15252, 47960, 154057, 47561, 47561, 47561, 0, 47520, 47520, 47561,
  47561, 47520, 47561, 47520, 47561, 47520, 47561, 47520, 47561, 47561, 47561, 47561, 291760, 47561, 48050, 47561,
  48052, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48408, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  1190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 852, 0, 0, 0, 1207, 0, 0, 0, 0, 0, 1212, 0, 0, 0, 0, 0, 0, 0,
  124928, 0, 124928, 124928, 0, 0, 124928, 124928, 0, 0, 1249, 47520, 47520, 47520, 47520, 180640, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 258464, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48376, 48377,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48385, 47520, 47520, 47520,
  47520, 46428, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 1248, 1249, 47520,
  48488, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48195, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 48500, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 48209, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 319904, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48505, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 48614, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 1634,
  1635, 0, 0, 47561, 47561, 47561, 319945, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 47561, 0, 0,
  0, 0, 0, 45429, 45429, 0, 45429, 395, 0, 45429, 45429, 395, 0, 45429, 47561, 47561, 47561, 47561, 393673, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 323, 0, 0, 0, 323, 0, 47520, 47520, 47520, 47520, 48801, 47520, 47520, 47520, 47520, 47520,
  47561, 47561, 48809, 47561, 47561, 47561, 47561, 47561, 48068, 47561, 47561, 47520, 0, 969, 971, 0, 0, 0, 973, 47520,
  47520, 48829, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 48837, 47561, 47561, 47561, 47561, 47561, 0, 0,
  0, 1631, 0, 0, 0, 0, 0, 0, 0, 375, 0, 55671, 375, 0, 0, 55671, 375, 0, 303, 0, 304, 0, 0, 0, 0, 0, 0, 0, 279, 304,
  282, 282, 303, 0, 0, 0, 0, 286, 288, 313, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 0, 0, 262, 0, 279, 303, 0, 303,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 522, 0, 0, 0, 0, 279, 0, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 282, 281, 0, 0,
  0, 0, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 281, 281, 353, 353, 353, 45418, 45418, 378, 45418, 387,
  378, 45418, 45418, 397, 378, 45418, 387, 378, 387, 378, 378, 404, 404, 387, 404, 404, 404, 404, 404, 404, 404, 404,
  412, 404, 404, 412, 47524, 404, 404, 404, 45418, 404, 45418, 404, 47551, 47551, 47566, 47551, 47551, 47551, 47566,
  47551, 47566, 47551, 47551, 47551, 47551, 47551, 47551, 47551, 47566, 47566, 47566, 47566, 47566, 47566, 47566, 47551,
  47551, 47566, 1, 8194, 3, 4, 41199, 41199, 0, 527, 0, 0, 0, 0, 0, 296, 296, 296, 0, 536, 0, 0, 0, 0, 0, 0, 65536,
  65536, 65536, 0, 0, 0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 0, 0, 0, 537, 0, 0, 540, 0, 542, 0, 0, 0,
  546, 547, 0, 0, 0, 0, 0, 0, 0, 0, 1456, 0, 0, 0, 0, 0, 0, 0, 45414, 45659, 45414, 45414, 45414, 45414, 0, 0, 0, 0,
  247808, 0, 281073, 299008, 0, 0, 0, 0, 0, 47520, 0, 0, 0, 45414, 0, 45414, 0, 47520, 47520, 47561, 47561, 47561,
  47561, 47561, 47561, 0, 0, 0, 47520, 240032, 334240, 47520, 47561, 0, 0, 0, 247808, 0, 280576, 0, 299008, 0, 0, 0, 0,
  0, 0, 0, 0, 1469, 1470, 0, 46528, 45414, 46530, 45414, 45414, 0, 582, 0, 0, 0, 0, 540, 0, 0, 0, 0, 0, 0, 414, 415,
  47520, 0, 0, 0, 0, 47561, 47561, 47561, 47561, 47561, 178633, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0,
  47520, 47520, 48826, 48827, 47520, 299424, 47520, 47759, 47781, 454, 455, 0, 47561, 47561, 47561, 47561, 47796, 47561,
  47561, 248265, 47561, 281283, 47561, 299465, 47561, 47561, 47819, 47822, 47826, 47561, 47561, 47561, 47561, 47520,
  479, 480, 0, 775, 776, 0, 296, 296, 536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59392, 0, 0, 0, 0, 0, 261, 786, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 797, 0, 0, 559, 0, 0, 0, 0, 296, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 317440, 1200, 1201, 0, 0, 855, 0,
  47960, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47974, 47520, 0, 0, 0, 0, 47561,
  47561, 47561, 48396, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48528, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 365001, 47561, 381385, 47561, 47561, 47561, 47561, 47561, 47520, 47994, 47520, 47520, 47998, 47520, 0,
  47520, 47520, 47520, 47520, 48004, 47520, 47520, 48007, 47520, 0, 0, 0, 0, 47561, 47561, 48395, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 227785, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 47987, 47520,
  47520, 47520, 47520, 0, 913, 915, 0, 15252, 47960, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 1716, 0, 0, 0, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48361, 47520, 47520, 47520, 47561, 48047, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 48054, 47561, 47561, 47561, 47561, 47561, 47561, 48260, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 0, 0, 1755, 0, 47520, 47520, 47520, 47561, 47561, 48064, 47561, 47561, 47561,
  48069, 47561, 47987, 0, 969, 971, 0, 0, 0, 973, 975, 0, 48054, 172032, 0, 0, 0, 980, 0, 0, 0, 0, 749, 0, 751, 0, 0, 0,
  0, 296, 296, 0, 0, 0, 0, 0, 0, 0, 0, 784, 785, 753, 0, 755, 992, 0, 0, 0, 0, 0, 0, 0, 0, 219136, 0, 0, 1002, 0, 1004,
  1005, 0, 1007, 0, 0, 0, 0, 0, 0, 1011, 0, 0, 0, 0, 0, 0, 77824, 0, 0, 0, 77824, 77824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 479, 27357, 0, 387072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 731, 732, 1043, 0, 0, 46101, 172390,
  45414, 45414, 45414, 45414, 219494, 45414, 46108, 45414, 45414, 45414, 46111, 45414, 46112, 45414, 45414, 45414,
  45414, 45414, 45414, 0, 1065, 0, 0, 1067, 0, 0, 0, 0, 0, 764, 0, 0, 0, 767, 0, 0, 0, 0, 0, 0, 0, 124928, 124928,
  124928, 1, 8194, 3, 4, 0, 0, 172032, 172032, 17454, 0, 853, 0, 855, 47960, 48179, 48180, 172448, 47520, 47520, 47520,
  47520, 47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 0, 969, 971, 0, 0, 0, 973,
  47520, 47520, 47520, 219552, 47520, 47520, 48192, 47520, 47520, 47520, 47520, 47520, 48197, 47520, 48199, 47520, 0, 0,
  0, 0, 47561, 48394, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 47520, 47520, 48863,
  48200, 48201, 47520, 47520, 47520, 47520, 47520, 360864, 47520, 47520, 47520, 47520, 47520, 47520, 48213, 47520, 0,
  1287, 0, 1288, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47831, 47561, 47520, 479,
  480, 913, 0, 915, 15252, 48230, 48231, 47561, 47561, 172489, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520,
  47520, 47561, 1, 8194, 3, 4, 41199, 41448, 47561, 47561, 47561, 219593, 47561, 47561, 48247, 47561, 47561, 47561,
  47561, 47561, 47561, 48253, 47561, 47561, 47561, 47561, 47561, 48246, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48409, 47561, 48411, 47561, 47561, 318750, 48255, 307657, 47561, 48256, 48257, 47561, 47561,
  47561, 47561, 48263, 47561, 360905, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 182272, 0, 0, 0, 0, 0, 0, 0, 807, 0,
  0, 0, 0, 0, 0, 0, 0, 290, 0, 0, 0, 0, 290, 0, 0, 48268, 47561, 47561, 47561, 47561, 48273, 47520, 0, 969, 0, 971, 0,
  973, 0, 975, 47561, 47520, 0, 1325, 0, 1326, 0, 1327, 0, 1328, 47561, 0, 0, 0, 0, 0, 0, 572, 0, 0, 575, 0, 0, 0, 0, 0,
  0, 0, 143360, 143360, 143360, 1, 8194, 3, 1061351, 0, 0, 0, 0, 0, 1193, 0, 0, 0, 1197, 0, 0, 0, 0, 0, 0, 0, 1203, 0,
  0, 1027, 0, 0, 0, 0, 403456, 0, 0, 0, 0, 0, 0, 1227, 0, 0, 0, 0, 296, 296, 0, 0, 0, 0, 0, 0, 0, 783, 0, 0, 0, 0, 0,
  65536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8194, 3, 4, 41199, 41199, 1229, 0, 0, 1232, 45414, 45414, 45414, 45414, 45414,
  46293, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 520, 0, 0, 0, 0, 0, 0, 0, 127353, 0, 127353, 127353, 0, 0,
  127353, 127353, 0, 0, 1249, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48360, 47520, 47520, 47520,
  47520, 47782, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48624, 47561, 47561, 47561, 47561,
  48629, 47520, 47561, 0, 0, 47520, 47520, 47520, 403872, 47520, 47520, 47520, 48381, 47520, 48383, 47520, 47520, 47520,
  48387, 47520, 47520, 47520, 0, 0, 584, 0, 0, 0, 0, 47732, 47520, 47520, 47520, 47742, 47520, 47561, 48402, 47561,
  48404, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47832, 47520, 479, 480,
  47561, 48416, 48417, 48418, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 403913, 0, 0,
  0, 0, 362496, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 551, 0, 0, 0, 555, 1249, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 48494, 47520, 47520, 47520, 47520, 47520, 293280, 47520, 0, 1287, 0, 1288, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48399, 47561, 47561, 47561, 47561, 47561, 48258, 48259, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 1691, 48499, 47520, 47520, 47520, 47520, 47520, 362912, 48503, 47520, 47520,
  47520, 47520, 47520, 48507, 47520, 47520, 47520, 0, 0, 156227, 0, 0, 0, 0, 47733, 47520, 47520, 47520, 47520, 47520,
  274848, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48833, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 258505, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48524, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 293321, 47561, 48532, 47561, 47561, 47561, 47561, 47561, 48420, 47561,
  47561, 47561, 47561, 47561, 48424, 47561, 47561, 47561, 47561, 47561, 47561, 48856, 47561, 47561, 190464, 0, 0, 0,
  47520, 48862, 47520, 45414, 46533, 45414, 0, 0, 1481, 47520, 47520, 47520, 47520, 199072, 47520, 47520, 47520, 47520,
  47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47805, 47561, 48594, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 17454, 0, 47520, 47520, 47561, 47561, 47561,
  47561, 47561, 47561, 199113, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47821, 47561, 47561, 47561, 47561,
  47561, 47520, 479, 480, 47561, 48620, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 340384,
  340425, 0, 1527, 335872, 0, 0, 0, 0, 0, 0, 0, 0, 1534, 1535, 0, 0, 0, 0, 1536, 0, 1537, 0, 0, 397312, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 45414, 45414, 45414, 272742, 45414, 272384, 176486, 45414, 45414, 270694, 45414, 46607, 176128, 270336,
  0, 47520, 47520, 176544, 47520, 47520, 47520, 47520, 47980, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 272800, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 291694, 47520, 47520,
  47985, 47520, 47520, 47520, 47520, 47520, 47520, 0, 0, 0, 0, 15252, 47960, 47561, 47561, 47561, 47561, 270752, 47520,
  47520, 47520, 47520, 48666, 48667, 395680, 47520, 47520, 48670, 47520, 47520, 47520, 48674, 47520, 0, 1287, 0, 1288,
  47561, 47561, 47561, 47561, 47561, 47561, 180681, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 1717, 0, 1719, 47520,
  48825, 47520, 47520, 47561, 47561, 47561, 176585, 47561, 47561, 47561, 48683, 47561, 47561, 270793, 47561, 47561,
  47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48851, 47520, 48689, 48691,
  47561, 48693, 395721, 0, 0, 0, 0, 0, 1594, 0, 294912, 1596, 0, 0, 0, 0, 0, 47520, 0, 0, 0, 45414, 0, 45414, 0, 47548,
  47548, 47563, 1637, 0, 0, 45414, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48751, 47520,
  0, 1287, 0, 1288, 47561, 47561, 47561, 47561, 48397, 47561, 47561, 48398, 47561, 47561, 48400, 0, 0, 0, 1664, 0,
  47520, 47520, 47520, 47520, 47520, 48775, 47520, 47520, 47520, 47520, 47561, 47520, 47561, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 47520, 47520, 48877, 48878, 47561, 47561,
  48783, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 1689, 0, 0, 0, 0, 0, 47520, 47520, 48772, 48773, 47520,
  47520, 47520, 47520, 47520, 47520, 47561, 47561, 162249, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 296535,
  47561, 47561, 215456, 47520, 47520, 47520, 47520, 47520, 47561, 47561, 215497, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47825, 47561, 47561, 47561, 47561, 47561, 47520, 479, 480, 167936, 1738, 0, 0, 0, 0, 0, 48846, 47520,
  47520, 47520, 223648, 297376, 47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 47744, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48220, 47520, 47520, 47520, 48222, 47520,
  47520, 47520, 47520, 17454, 0, 48852, 47561, 223689, 47561, 297417, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 47520,
  47520, 47520, 47520, 47520, 48802, 47520, 47520, 47520, 47520, 47561, 47561, 47561, 48810, 47561, 47520, 352672,
  47561, 48880, 47561, 47561, 47561, 352713, 0, 0, 0, 47520, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561,
  47561, 0, 0, 0, 47520, 48876, 47520, 47520, 306, 0, 36864, 38912, 0, 306, 309, 0, 0, 255, 34816, 255, 255, 255, 255,
  0, 0, 0, 0, 296, 296, 0, 0, 0, 0, 781, 762, 0, 0, 0, 0, 0, 0, 57344, 120832, 129024, 0, 0, 0, 0, 0, 0, 0, 296, 296,
  102400, 0, 0, 0, 0, 0, 0, 0, 255, 306, 255, 255, 255, 255, 306, 255, 255, 255, 255, 255, 255, 255, 255, 45419, 45419,
  255, 45419, 0, 255, 45419, 45419, 0, 255, 45419, 255, 255, 255, 255, 255, 47525, 255, 255, 255, 45419, 255, 45419,
  439, 47552, 47552, 47567, 47552, 47552, 47552, 47567, 47552, 47567, 47552, 47552, 47552, 47552, 47552, 47552, 47552,
  47567, 47567, 47567, 47567, 47567, 47567, 47567, 47552, 47552, 47567, 1, 8194, 3, 4, 41199, 41199, 260512, 47520,
  47520, 47520, 47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48626, 47561, 47561, 47561,
  47520, 47561, 0, 0, 260553, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520,
  479, 480, 855, 0, 47960, 47520, 47520, 47520, 47520, 47520, 47969, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  295328, 47520, 47520, 47520, 162208, 47520, 47520, 296524, 47520, 47561, 47561, 47561, 48032, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48041, 47561, 47561, 47561, 0, 0, 0, 0, 1346, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 810, 0, 0, 0, 0, 47561, 47561, 47561, 48536, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47520, 1325, 1326, 1327, 1328, 47520, 47520, 152009, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 47520, 47520, 47520,
  47520, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 151968, 47520, 47520, 47520, 0, 0, 36864, 38912, 0, 0, 0, 0,
  0, 336, 34816, 336, 336, 336, 336, 344, 336, 336, 336, 336, 336, 45420, 45420, 379, 45420, 388, 379, 45420, 45420,
  388, 379, 45420, 388, 379, 388, 379, 379, 379, 379, 388, 379, 379, 379, 379, 379, 379, 379, 379, 47526, 379, 379, 379,
  45420, 379, 45420, 379, 47526, 47526, 47568, 47526, 47526, 47526, 47568, 47526, 47568, 47526, 47526, 47526, 47526,
  47526, 47526, 47526, 47568, 47568, 47568, 47568, 47568, 47568, 47568, 47526, 47526, 47568, 1, 8194, 3, 4, 41199,
  41199, 385024, 0, 147456, 0, 0, 0, 0, 1540, 0, 0, 0, 0, 1544, 0, 0, 45414, 45414, 45414, 45414, 46115, 45414, 45414,
  45414, 0, 0, 0, 0, 0, 0, 0, 0, 1185, 0, 1186, 0, 1187, 0, 1188, 0, 0, 0, 0, 0, 1600, 0, 0, 0, 157696, 0, 158054,
  45414, 45414, 45414, 45414, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 201120, 47520, 47520, 47520, 47520, 47981,
  285088, 47520, 47520, 47520, 47520, 47520, 47520, 47989, 47990, 47520, 47520, 47520, 158112, 47520, 47520, 47520,
  239176, 47520, 47520, 333385, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 0, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 48055, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 206848, 207206, 47520,
  47520, 207264, 47520, 47520, 47520, 47520, 47520, 48749, 47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 0, 47520, 47520,
  47520, 47520, 47773, 47520, 47561, 47561, 207305, 47561, 47561, 47561, 47561, 47561, 48759, 47561, 47561, 47561, 0, 0,
  0, 0, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 1040, 0, 240073, 334281, 47561, 0, 47520, 47520, 47561, 47561, 47520, 47561,
  47520, 47561, 47520, 47561, 47520, 47561, 47520, 1171, 1325, 1173, 1326, 1175, 1327, 1177, 1328, 47561, 0, 0, 0, 0, 0,
  0, 1444, 0, 0, 0, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 211302, 45414, 45414, 0, 567, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 799, 1027, 47520, 47765, 47520, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 47735, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 17454, 1123, 0, 744, 0, 0, 0, 0, 749,
  751, 0, 0, 753, 755, 0, 0, 0, 0, 0, 0, 126976, 0, 0, 0, 126976, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47520, 47520,
  48011, 47520, 47520, 47520, 0, 913, 915, 0, 15252, 47960, 47561, 47561, 47561, 47561, 47561, 0, 0, 1592, 0, 0, 0, 0,
  0, 0, 0, 0, 291, 292, 0, 0, 0, 0, 0, 296, 178176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1027, 1450, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1042, 0, 0, 0, 45414, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 389536, 284, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0,
  283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 968, 970, 0, 0, 0, 972, 0, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851, 0,
  0, 0, 0, 283, 0, 0, 0, 0, 0, 0, 0, 0, 283, 0, 0, 0, 0, 0, 791, 0, 0, 0, 0, 0, 0, 798, 0, 559, 0, 0, 0, 36864, 38912,
  0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 345, 389, 380, 389, 403, 403, 405, 389, 389, 389, 389, 389, 389, 389, 389, 389,
  389, 413, 389, 389, 413, 47527, 389, 389, 389, 45421, 389, 45421, 389, 47553, 47553, 47569, 47553, 47553, 47553,
  47569, 47553, 47569, 47553, 47553, 47553, 47553, 47553, 47553, 47553, 47569, 47569, 47569, 47569, 47569, 47569, 47569,
  47553, 47553, 47569, 1, 8194, 3, 4, 41199, 41199, 0, 610, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1014, 0, 0, 610,
  0, 0, 0, 0, 610, 0, 0, 0, 0, 0, 0, 414, 415, 47520, 1122, 1287, 1124, 1288, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48531, 47561, 47561, 47561, 47520, 47520, 47738, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 393632, 47520, 47520, 47520, 47520, 47520, 0, 0, 0,
  843, 0, 0, 0, 847, 0, 0, 0, 0, 0, 0, 0, 853, 855, 0, 47960, 47520, 47520, 47520, 47965, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 407968, 47520, 166304, 47520, 47520, 47520, 47520, 47520, 47520, 47978, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48382, 47520, 47520, 47520, 47520,
  47520, 48388, 47520, 47520, 47520, 47995, 47520, 47520, 47520, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 48497, 47520, 47520, 47520, 47520, 47520, 48012, 47520, 47520, 0, 913, 915, 0,
  15252, 47960, 47561, 47561, 47561, 47561, 47561, 0, 0, 1715, 0, 0, 1718, 0, 47520, 47520, 47520, 47520, 47520, 47520,
  48493, 47520, 47520, 47520, 47520, 48496, 47520, 47520, 47520, 47561, 48027, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48043, 47561, 47561, 47561, 47561, 47561, 362953, 47561, 47561, 48539,
  47561, 47561, 47520, 1325, 1326, 1327, 1328, 48062, 47561, 47561, 47561, 48066, 47561, 47561, 47561, 48071, 0, 969,
  971, 0, 0, 0, 973, 975, 0, 48080, 0, 0, 0, 0, 0, 981, 0, 0, 0, 749, 0, 751, 0, 0, 0, 0, 296, 296, 0, 0, 779, 780, 0,
  0, 0, 0, 0, 0, 0, 578069, 578069, 296, 0, 0, 0, 0, 0, 0, 0, 77824, 0, 0, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 265, 0, 0, 0,
  753, 0, 755, 0, 0, 0, 0, 0, 0, 998, 0, 0, 0, 0, 0, 0, 0, 153600, 153958, 45414, 45414, 45414, 45414, 45414, 45414,
  45414, 0, 0, 0, 0, 0, 0, 17454, 1071, 1248, 1003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1010, 0, 0, 0, 0, 0, 0, 765, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 96639, 0, 0, 0, 96639, 0, 0, 1028, 0, 0, 0, 0, 0, 0, 0, 1034, 1035, 0, 1037, 0, 0, 0, 0, 0, 0, 327680,
  0, 0, 0, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47520, 48590, 47520, 47520,
  47520, 45414, 45414, 45414, 46114, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 0, 0, 32768, 0, 0, 0, 0, 0, 0, 0,
  47561, 47561, 47561, 48271, 47561, 47561, 47520, 0, 969, 0, 971, 0, 973, 0, 975, 47561, 47561, 47561, 47561, 48049,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48060, 47561, 47561, 47561, 47561, 48067, 47561, 47561,
  47561, 48010, 0, 969, 971, 0, 0, 0, 973, 1218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1189, 1358, 0, 0, 0, 0, 0,
  0, 1363, 1364, 0, 0, 1367, 0, 0, 0, 0, 0, 0, 413696, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47960, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48672, 47520, 47520, 48510, 47520, 47520, 47520, 47520,
  47520, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 354761, 0, 1754, 0, 1756, 47520, 47520, 47520, 0,
  1451, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1041, 0, 45414, 45414, 46534, 0, 0, 0, 47520, 48587, 47520, 48589,
  47520, 47520, 47520, 47520, 48592, 47520, 47520, 47520, 583, 0, 0, 0, 286720, 663, 0, 47768, 47520, 47520, 47520,
  47520, 47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47802, 47561, 47561, 47520, 47520, 47520, 48596, 47520,
  48598, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48601, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 48608, 47561, 48610, 47561, 47561, 48613, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48617,
  47561, 47561, 47561, 47561, 48245, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48252, 47561, 47561, 47561, 0,
  47520, 47520, 47561, 47561, 48891, 48892, 47520, 47561, 47520, 47561, 47520, 47561, 0, 163840, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1216, 0, 45414, 45414, 46605, 45414, 45414, 45414, 0, 0, 0, 47520, 47520, 47520, 47520, 48661,
  47520, 47520, 47520, 0, 552, 0, 544, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47774, 0, 47520, 47520, 48799, 48800,
  47520, 47520, 47520, 48804, 48805, 47520, 47561, 47561, 47561, 47561, 48811, 47561, 48813, 48814, 48815, 47561, 0, 0,
  0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 48774, 47520, 47520, 47520, 47520, 47520, 47561, 48864, 47520, 47520,
  47561, 47561, 48869, 48870, 47561, 47561, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 48362, 0, 0, 36864, 38912, 0, 0, 330, 0, 0, 256, 34816, 256, 256, 256, 256, 0, 0, 0, 0,
  296, 296, 0, 778, 0, 0, 0, 0, 0, 0, 0, 0, 266, 0, 1, 8194, 3, 4, 41199, 41199, 256, 256, 256, 256, 256, 45422, 45422,
  381, 45422, 390, 381, 45422, 45422, 390, 381, 45422, 390, 381, 390, 381, 381, 381, 381, 390, 381, 381, 381, 381, 381,
  381, 381, 381, 47528, 381, 381, 381, 45422, 381, 45422, 440, 47528, 47528, 47570, 47528, 47528, 47528, 47570, 47528,
  47570, 47528, 47528, 47528, 47528, 47528, 47528, 47528, 47570, 47570, 47570, 47570, 47570, 47570, 47570, 47528, 47528,
  47570, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 555, 0, 559, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1366, 0, 0, 0, 0, 0, 519, 0,
  0, 0, 0, 45414, 45414, 45414, 45414, 45647, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48389, 855, 0, 47960,
  47520, 47520, 47520, 47520, 47966, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 0, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 48521, 47976, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47984, 47520, 47520, 47520,
  47520, 47520, 47991, 47520, 47520, 47520, 47520, 346528, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48506,
  47520, 48508, 47520, 47520, 47520, 47520, 373152, 47520, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  48789, 0, 0, 0, 1688, 0, 0, 0, 47520, 47520, 47520, 47997, 47520, 47520, 0, 47520, 47520, 47966, 47520, 47520, 47520,
  47520, 47520, 47520, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561, 48520, 47561, 47561, 47561, 48028, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48040, 47561, 47561, 47561, 47561, 47561, 0, 1591, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 86016, 0, 0, 0, 0, 0, 0, 753, 0, 755, 0, 0, 994, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1471, 45414, 45414, 45414, 45414,
  46531, 243712, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1344, 0, 0, 0, 45414, 45414, 46103, 45414, 45414, 45414,
  45414, 45414, 45414, 45414, 45414, 45414, 45414, 362854, 0, 0, 0, 0, 1248, 0, 0, 17454, 0, 853, 0, 855, 47960, 47520,
  47520, 47520, 47520, 48183, 48184, 47520, 48186, 913, 0, 915, 15252, 47561, 47561, 47561, 47561, 47561, 47561, 48236,
  48237, 47561, 47561, 48240, 47561, 47561, 47561, 47561, 48419, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48410, 47561, 47561, 47561, 47561, 0, 1180, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1356, 0,
  45414, 45414, 46299, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 17454, 0, 0, 0, 0, 47960, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 48370, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 45414, 45414, 45414, 46431,
  45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 17454, 0, 0, 48522, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48061, 0, 1463, 0, 0, 0, 0, 1468,
  0, 0, 0, 0, 45414, 46529, 45414, 45414, 45414, 45414, 45414, 45664, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 848, 0, 0, 0, 0,
  853, 47520, 47520, 47561, 47561, 47561, 48612, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 389577, 0, 0, 0, 0, 1597, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 48586, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 913, 915, 0, 15252, 47960, 48021, 48022, 47561, 47561,
  47520, 48719, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48042,
  47561, 47561, 47561, 47561, 48731, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 47561, 47561,
  47561, 48854, 47561, 48855, 47561, 47561, 47561, 0, 0, 0, 0, 48861, 47520, 47520, 47520, 0, 615, 0, 0, 0, 0, 615,
  47520, 47520, 47520, 47520, 47520, 47520, 0, 47520, 48001, 47520, 47520, 47520, 47520, 48006, 47520, 47520, 47520,
  47520, 47520, 48867, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 221600, 231840, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0,
  48885, 47520, 47520, 47520, 48887, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1461, 0, 0, 36864, 38912, 0, 0,
  0, 0, 0, 0, 34816, 0, 0, 0, 0, 346, 399, 0, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391,
  47529, 391, 391, 391, 45423, 391, 45423, 391, 47529, 47529, 47571, 47529, 47529, 47529, 47571, 47529, 47571, 47529,
  47529, 47529, 47529, 47529, 47529, 47529, 47571, 47571, 47571, 47571, 47571, 47571, 47571, 47529, 47529, 47571, 1,
  8194, 3, 4, 41199, 41448, 520, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45648, 45414, 45414, 45414, 45414, 45414,
  45414, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 213408, 47520, 47748, 47520, 47520, 47520, 47520, 454, 455, 0,
  47561, 47561, 47561, 47561, 47561, 47800, 47561, 47561, 47561, 47561, 47561, 48623, 47561, 47561, 47561, 47561, 47561,
  47561, 47520, 47561, 0, 0, 0, 0, 0, 47532, 0, 0, 0, 45414, 0, 45414, 0, 47555, 47555, 47574, 47808, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 479, 480, 47561, 47561, 48029, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48266, 375241, 47561, 753, 0, 755,
  0, 0, 0, 0, 0, 0, 0, 0, 1000, 0, 0, 276480, 0, 0, 0, 0, 296, 296, 536, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1365, 0, 0, 0, 0, 0,
  0, 47520, 48216, 47520, 48218, 47520, 47520, 276896, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 17454, 0, 0, 0,
  0, 296, 296, 23063, 25354, 0, 0, 0, 0, 0, 0, 0, 0, 322, 0, 0, 318, 0, 322, 322, 318, 913, 0, 915, 15252, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48238, 47561, 47561, 47561, 0, 47520, 47520, 47561, 47561, 47520, 47561,
  47520, 47561, 47520, 47561, 342432, 342473, 47561, 47561, 48244, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 276937, 47561, 47561, 47561, 47561, 48526, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47520, 1325, 1326, 1327, 1328, 47561, 47561, 48403, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48412, 47561, 47561, 0, 1662, 0, 0, 0, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 48779, 47561, 47561, 47561, 47561, 48537, 47561, 47561, 47561, 47561,
  48540, 47561, 47520, 1325, 1326, 1327, 1328, 0, 285, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1460, 0, 0, 258, 312,
  259, 0, 0, 0, 0, 0, 0, 0, 285, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 0, 0, 0, 0, 0, 539, 0, 0, 36864,
  38912, 312, 0, 0, 0, 285, 0, 34816, 0, 0, 0, 0, 0, 0, 792, 0, 794, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 0, 562, 0, 0, 0, 0,
  382, 382, 382, 382, 382, 382, 382, 392, 382, 382, 382, 382, 382, 382, 382, 382, 47530, 382, 382, 382, 45424, 382,
  45424, 382, 47554, 47554, 47572, 47554, 47554, 47554, 47572, 47554, 47572, 47554, 47554, 47554, 47554, 47554, 47554,
  47554, 47572, 47572, 47572, 47572, 47572, 47572, 47572, 47554, 47554, 47572, 1, 8194, 3, 4, 41199, 41199, 498, 0, 0,
  0, 261, 262, 0, 264, 265, 0, 0, 0, 0, 0, 0, 0, 493, 0, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 549, 0, 0,
  0, 0, 0, 0, 0, 319488, 0, 0, 0, 0, 0, 0, 0, 0, 1350, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 543, 584, 45414, 45641, 45414,
  45414, 45649, 45414, 45414, 45654, 45414, 45414, 45414, 45414, 45414, 45887, 45414, 45414, 45414, 45414, 45414, 45414,
  45414, 45414, 45414, 45414, 1244, 0, 1246, 0, 0, 0, 17454, 0, 1248, 45657, 45414, 45414, 45414, 45663, 45414, 0, 0, 0,
  521, 0, 0, 0, 0, 0, 584, 0, 0, 0, 521, 618, 0, 0, 0, 0, 0, 584, 521, 264805, 414, 415, 47520, 47520, 47520, 47561,
  48868, 47561, 47561, 47561, 47561, 0, 0, 0, 47520, 47520, 47520, 47520, 47520, 47520, 192928, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47732, 47520, 47520, 47742, 47520, 47520, 47749, 47520, 47520, 47520, 47753, 47520, 47520,
  47520, 47520, 47763, 47749, 47520, 47520, 47520, 47520, 454, 455, 0, 47561, 47789, 47561, 47561, 47561, 47801, 47561,
  47561, 47561, 47561, 47561, 48680, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  242121, 47561, 47561, 47561, 47561, 47809, 47561, 47561, 47561, 47815, 47561, 47561, 47561, 47561, 47829, 47561,
  47561, 47561, 47520, 479, 480, 759, 760, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14336, 0, 0, 0, 0, 777, 296, 296,
  0, 0, 0, 0, 0, 0, 782, 0, 0, 0, 0, 0, 1008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49403, 51452, 0, 0, 0, 0, 0, 0, 759, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 813, 0, 0, 0, 0, 414, 0, 415, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 753, 0,
  755, 0, 993, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 0, 0, 1029, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  812, 0, 0, 0, 0, 0, 45414, 45414, 45414, 46104, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 46435,
  45414, 0, 0, 0, 0, 1248, 0, 0, 17454, 0, 853, 0, 855, 47960, 47520, 47520, 47520, 47520, 47520, 47520, 48185, 47520,
  47520, 47520, 47561, 158153, 47561, 47561, 47561, 47561, 47561, 47561, 239190, 47561, 47561, 333400, 47561, 47520, 0,
  1325, 0, 1326, 0, 1327, 0, 1328, 47561, 292864, 0, 0, 1332, 0, 0, 0, 0, 296, 296, 0, 0, 0, 0, 0, 763, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 769, 0, 0, 772, 0, 913, 0, 915, 15252, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 48239, 47561, 47561, 47561, 47561, 47561, 48681, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48688,
  47561, 0, 0, 1231, 0, 46289, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 47520, 48355, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 0, 913, 915, 0, 15252, 47960, 47561, 47561, 47561, 48024, 391584, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48673, 47520, 48415, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 391625, 47561, 47561, 47561, 0, 47520, 47520, 47561, 47561, 47520, 47561,
  47520, 47561, 48895, 48896, 47520, 47561, 346112, 0, 0, 0, 0, 1347, 0, 0, 0, 0, 0, 0, 1354, 0, 0, 0, 0, 0, 1018, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 159744, 0, 0, 414, 415, 47520, 47561, 48523, 47561, 48525, 47561, 47561, 47561, 47561, 47561,
  48529, 47561, 47561, 47561, 47561, 47561, 47561, 48274, 0, 969, 0, 971, 0, 973, 0, 975, 48283, 47561, 47561, 346569,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 0, 0, 0, 0, 807, 0, 0, 0, 0, 0, 1453, 0, 399360, 0, 0,
  0, 0, 1457, 0, 0, 1459, 0, 0, 0, 0, 0, 47539, 0, 0, 0, 45414, 0, 45414, 0, 47539, 47539, 47581, 0, 0, 1464, 0, 0,
  1467, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45653, 45414, 45414, 45414, 47520, 47520, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48615, 47561, 47561, 47561, 47561, 47561, 0, 1629, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 1033, 0, 0, 0, 0, 0, 0, 0, 0, 520, 0, 0, 0, 0, 0, 0, 0, 520, 0, 414, 415, 47520, 47520, 47520, 47520,
  48665, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 246176, 47520, 47520, 47520, 47520, 48013, 47520, 0, 913, 915,
  0, 15252, 47960, 47561, 47561, 47561, 47561, 47561, 1590, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1199, 0, 0, 0, 0, 0, 47561,
  48677, 47561, 47561, 47561, 47561, 47561, 47561, 48684, 246217, 47561, 47561, 47561, 48687, 47561, 47561, 47561,
  47561, 47561, 48756, 48757, 48758, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 1442, 1443, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  83968, 0, 0, 0, 83968, 0, 0, 47520, 47520, 182688, 48710, 48711, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 48717, 0, 0, 0, 45414, 47520, 47520, 47520, 47520, 47520, 48746, 47520, 47520, 47520, 47520,
  47520, 47520, 0, 913, 915, 0, 15252, 47960, 47561, 47561, 48023, 47561, 47561, 47561, 47561, 48754, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288768, 47520, 47520, 47520, 48830, 47520,
  48832, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48839, 47561, 48841, 47520, 47520, 47561, 47561, 48881, 48882,
  47561, 47561, 0, 0, 0, 47520, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 1769, 0, 1771, 47520,
  47520, 47520, 47520, 48190, 47520, 47520, 47520, 47520, 47520, 47520, 48196, 47520, 47520, 47520, 47520, 48204, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47999, 0, 47520, 47520, 47967, 47520, 47520,
  47520, 47520, 47520, 47520, 47746, 47520, 47520, 47520, 47520, 316042, 47756, 47520, 47520, 47762, 47520, 0, 0, 0,
  286, 287, 288, 289, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 0, 0, 0, 0, 538, 0, 288, 0, 36864, 38912, 0, 287, 0, 289,
  289, 288, 34816, 288, 288, 341, 288, 0, 0, 0, 0, 490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 0, 0, 288, 288, 341,
  356, 356, 45425, 45425, 356, 45425, 393, 356, 45425, 45425, 393, 356, 45425, 393, 356, 401, 356, 356, 356, 356, 408,
  356, 356, 356, 356, 356, 356, 356, 356, 47531, 356, 356, 356, 45425, 356, 45425, 356, 47531, 47531, 47573, 47531,
  47531, 47531, 47573, 47531, 47573, 47531, 47531, 47531, 47531, 47531, 47531, 47531, 47573, 47573, 47573, 47573, 47573,
  47573, 47573, 47531, 47531, 47573, 1, 8194, 3, 4, 41199, 41199, 0, 499, 500, 0, 261, 262, 0, 264, 265, 0, 0, 0, 0, 0,
  511, 0, 0, 0, 0, 503, 504, 0, 507, 508, 0, 0, 0, 0, 0, 0, 0, 296, 296, 296, 0, 0, 73728, 0, 0, 0, 512, 513, 514, 515,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1214, 0, 0, 0, 0, 0, 0, 569, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 569, 0, 0, 45414,
  45414, 45644, 45414, 45414, 45651, 45414, 45414, 45414, 45656, 45414, 45414, 45414, 45414, 379238, 45414, 45414, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 110931, 0, 0, 0, 0, 0, 47520, 47736, 47739, 47520, 47745, 47520, 47520, 47520, 47751, 47520,
  47520, 47520, 47520, 47760, 379296, 47520, 47520, 47520, 47740, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 48668, 214557, 47520, 47520, 47520, 47520, 47520, 48675, 47520, 47777, 47520,
  47760, 379296, 454, 455, 0, 47561, 47561, 47561, 47795, 47798, 47561, 47804, 47561, 47561, 47561, 47561, 48622, 47561,
  47561, 48625, 47561, 48627, 47561, 47561, 47520, 47561, 0, 0, 0, 0, 0, 47520, 48771, 47520, 47520, 47520, 47520,
  47520, 48777, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 47520, 47520, 47520, 48886, 47561,
  47561, 47561, 47812, 47814, 47561, 47561, 47561, 47823, 379337, 47561, 47561, 47561, 47561, 47520, 479, 480, 45414,
  45414, 45414, 45885, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0,
  1248, 47520, 47977, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47988, 47520, 47520, 47520, 47520,
  48219, 47520, 47520, 47520, 47520, 47520, 47520, 48224, 375200, 47520, 17454, 0, 47520, 47520, 47996, 47520, 47520,
  47520, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 48010, 47520, 47520, 47520, 47520, 0, 913, 915,
  0, 15252, 47960, 47561, 47561, 47561, 47561, 47561, 1713, 1714, 0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 47520,
  47520, 48776, 47520, 47520, 47520, 47561, 975, 0, 48055, 0, 0, 0, 0, 0, 0, 0, 0, 0, 749, 0, 751, 0, 0, 0, 0, 525, 0,
  0, 573, 0, 0, 0, 0, 0, 0, 0, 0, 131072, 0, 0, 0, 0, 0, 0, 0, 47561, 48269, 47561, 47561, 47561, 47561, 47520, 0, 969,
  0, 971, 0, 973, 0, 975, 47561, 47561, 47561, 47561, 48679, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48251, 47561, 47561, 47561, 47561, 1204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4096, 0,
  48363, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  364960, 381344, 0, 1359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27354, 480, 0, 0, 0, 0, 1454, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 14336, 0, 0, 0, 0, 47520, 47520, 48609, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48618, 0, 0, 0, 1529, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1225, 0, 0, 0, 45414, 46604, 45414,
  45414, 45414, 45414, 0, 0, 0, 47520, 47520, 47520, 48659, 47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 0, 47520, 47769,
  47520, 47738, 47520, 47520, 0, 0, 0, 45414, 48742, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  48498, 48752, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 1659, 0, 0, 0, 0,
  530, 531, 0, 296, 296, 296, 0, 0, 0, 0, 0, 0, 0, 127353, 127353, 127353, 1, 8194, 0, 4, 0, 0, 47561, 48782, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1449, 0, 47520, 48798, 47520,
  47520, 47520, 47520, 48803, 47520, 47520, 47520, 47561, 48808, 47561, 47561, 47561, 0, 47520, 47520, 47561, 47561,
  47520, 47561, 48893, 48894, 47520, 47561, 47520, 47561, 48812, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 48359, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47561, 47561,
  47561, 47561, 47561, 47561, 0, 1780, 0, 47520, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  48725, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 48824, 47520, 47520, 47520, 0, 0, 0, 260, 0, 0, 0, 260,
  0, 0, 0, 0, 0, 0, 0, 318, 0, 0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 0, 67584, 67584, 67584, 67584, 0, 0, 0, 0, 0, 0,
  36864, 38912, 322, 318, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 347, 47555, 47555, 47555, 47574, 47555, 47574, 47555, 47555,
  47582, 47582, 47582, 47582, 47555, 47574, 47574, 47574, 47574, 47574, 47574, 47589, 47555, 47555, 47574, 1, 8194, 3,
  4, 41199, 41199, 524, 0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 0, 414, 415, 47520, 47520, 47520, 47741, 47520, 47520, 47748,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 913, 915, 0, 15252, 47960, 47561, 47561, 47561,
  47561, 0, 0, 761, 0, 0, 0, 0, 766, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 802, 761, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1013, 0, 0, 855, 0, 47960, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47973,
  47520, 47520, 47520, 0, 0, 0, 0, 0, 0, 562, 47520, 47520, 47520, 47520, 47520, 47520, 48379, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 48504, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47979, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 47520, 47520,
  47520, 47520, 47520, 48005, 47520, 47520, 47520, 47561, 47561, 47561, 48065, 47561, 47561, 47561, 47561, 47520, 0,
  969, 971, 0, 0, 0, 973, 975, 0, 47561, 0, 0, 0, 0, 0, 0, 982, 0, 0, 749, 0, 751, 0, 0, 0, 0, 543, 0, 0, 0, 574, 0, 0,
  0, 0, 0, 0, 0, 793, 0, 0, 0, 0, 0, 0, 559, 0, 47520, 47520, 47520, 48203, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 0, 47520, 47520, 47520, 47520, 47972, 47520, 47520, 47520, 47520, 47520,
  252320, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0, 47520,
  47520, 47520, 48003, 47520, 47520, 47520, 47520, 47520, 47520, 48511, 47520, 47520, 47520, 47520, 0, 0, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48261, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48407, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 48248, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48037,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 48044, 0, 0, 1663, 0, 1665, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47561, 48834, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48422, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48070, 47520, 0, 969, 971, 0, 0, 0, 973, 0, 0, 229376, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 229376, 0, 0, 0, 0, 0, 1195, 0, 0, 0, 0, 0, 0, 0, 0, 1202, 0, 47520, 47520, 47766, 0, 0, 0, 0, 0, 0, 0, 47520,
  47520, 47520, 47520, 229792, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 0,
  47520, 47520, 48002, 47520, 47520, 47520, 47520, 47520, 48008, 0, 0, 36864, 38912, 0, 0, 0, 0, 0, 290, 34816, 290,
  290, 290, 290, 0, 0, 0, 0, 579, 45414, 45642, 45414, 45414, 45414, 45414, 45414, 274790, 45414, 45414, 45414, 45414,
  45414, 45888, 285030, 45414, 45414, 45414, 45891, 45892, 45414, 45414, 45414, 45414, 45414, 45414, 403814, 0, 0, 0, 0,
  0, 0, 17454, 0, 1248, 0, 290, 0, 290, 290, 290, 290, 0, 290, 290, 290, 290, 290, 290, 290, 290, 45426, 45426, 290,
  45426, 0, 290, 45426, 45426, 0, 290, 45426, 290, 290, 290, 290, 290, 47533, 290, 290, 290, 45426, 290, 45426, 290,
  47533, 47533, 47575, 47533, 47533, 47533, 47575, 47533, 47575, 47533, 47533, 47533, 47533, 47533, 47533, 47533, 47575,
  47575, 47575, 47575, 47575, 47575, 47575, 47533, 47533, 47575, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 501, 261, 262, 0,
  264, 265, 0, 0, 0, 0, 0, 0, 0, 808, 0, 0, 0, 0, 0, 0, 0, 0, 1009, 0, 0, 0, 0, 0, 0, 0, 526, 0, 0, 0, 0, 0, 0, 296,
  296, 296, 0, 0, 0, 0, 0, 0, 0, 416140, 416140, 416140, 1, 8194, 3, 4, 0, 0, 0, 556, 0, 0, 0, 559, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 565, 0, 0, 0, 315917, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45652, 45414, 45414, 45414, 45414, 45414,
  45414, 46118, 45414, 0, 0, 0, 0, 0, 0, 1069, 0, 315994, 45414, 45414, 45662, 45414, 45414, 0, 0, 0, 0, 565, 0, 0, 0,
  0, 0, 0, 846, 0, 0, 0, 0, 0, 0, 0, 0, 853, 315392, 0, 0, 0, 0, 0, 0, 315918, 0, 0, 0, 0, 0, 414, 415, 47520, 47520,
  47520, 47779, 47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48053, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47520, 47520, 47778, 47520, 47762, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47806, 47561, 47561, 47561, 47561, 316104, 47818, 47561, 47561, 47827, 47561, 47561, 47561, 47561, 47833, 479,
  480, 0, 482, 483, 0, 47843, 0, 4, 41199, 0, 0, 0, 0, 0, 0, 0, 241664, 801, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 45414, 815, 816, 0, 0, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 46296,
  317798, 45414, 45414, 242022, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  45414, 383334, 45414, 45414, 242080, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47986, 47520,
  47520, 47520, 47520, 47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47799, 47561, 47561, 975, 0, 47561, 0, 0,
  0, 979, 0, 0, 0, 0, 0, 749, 0, 751, 0, 0, 0, 0, 612, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 307, 0, 0, 0, 0, 0, 0, 979,
  45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 175144, 0, 0, 1066, 0, 0,
  0, 996, 913, 0, 915, 15252, 47561, 47561, 48232, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 1686,
  0, 1687, 0, 0, 1690, 0, 47561, 47561, 48270, 47561, 48272, 47561, 47520, 0, 969, 0, 971, 0, 973, 0, 975, 47561, 47561,
  47561, 47561, 48755, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 393216, 0, 0, 0,
  1181, 0, 1183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 0, 0, 79872, 0, 0, 0, 0, 1206, 0, 0, 0, 0, 0, 1211, 0, 0, 0, 0,
  0, 0, 0, 912, 914, 0, 0, 0, 0, 0, 0, 0, 278, 0, 305, 0, 0, 0, 0, 0, 0, 46297, 45414, 45414, 45414, 45414, 45414,
  45414, 0, 0, 0, 1247, 0, 0, 17454, 0, 0, 0, 0, 0, 251904, 0, 0, 0, 0, 0, 1224, 0, 0, 0, 0, 0, 261, 0, 0, 0, 264, 0, 0,
  0, 0, 0, 0, 0, 61440, 61440, 0, 530667, 8194, 3, 4, 0, 0, 47520, 47520, 48364, 47520, 48366, 47520, 47520, 318705,
  47520, 47520, 47520, 48373, 47520, 47520, 47520, 47520, 48378, 47520, 48380, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 1287, 1288, 47561, 47561, 48517, 47561, 48518, 47561, 47561, 47561, 48427, 47520, 0, 0, 0, 0, 0,
  0, 0, 0, 47561, 0, 0, 0, 0, 1333, 0, 47520, 47520, 47520, 47520, 48491, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 1287, 1288, 47561, 48516, 47561, 47561, 47561, 47561, 47561, 47561, 48035, 47561, 47561,
  48038, 47561, 47561, 47561, 47561, 47561, 47561, 48051, 47561, 47561, 47561, 47561, 47561, 47561, 48059, 47561, 47561,
  47520, 47520, 47520, 48501, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47747,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48371, 48372, 47520, 47520, 47520, 47520, 47520, 47561,
  48535, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 0, 0, 0, 0, 0, 0, 0, 0, 47561, 0, 0,
  1331, 0, 0, 151076, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 48267, 1661, 0, 0, 0, 0, 48770, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48778, 47520, 48780, 48879,
  47520, 47561, 47561, 47561, 47561, 48883, 47561, 196608, 0, 325632, 47520, 47520, 47520, 47520, 47561, 47561, 47561,
  182729, 48722, 48723, 47561, 47561, 47561, 47561, 47561, 47561, 48729, 47561, 47561, 47561, 253952, 47520, 47520,
  47561, 47561, 47520, 47561, 47520, 47561, 47520, 47561, 47520, 47561, 47561, 47561, 47561, 48785, 47561, 47561, 47561,
  47561, 0, 186368, 0, 0, 0, 0, 0, 0, 806, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 61440, 61440, 0, 61440, 0, 249, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28672, 0, 0, 319, 0, 0, 0, 0, 0, 321, 0, 0, 316, 0, 0, 0, 0, 0, 0, 1019, 0, 0, 0,
  0, 0, 0, 1026, 0, 0, 0, 0, 36864, 38912, 0, 0, 331, 0, 0, 337, 34816, 337, 337, 337, 337, 0, 0, 0, 0, 613, 0, 0, 0, 0,
  0, 616, 0, 539, 0, 0, 0, 0, 0, 805, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0, 0, 0, 159744, 337, 337, 354, 354, 354,
  45427, 45427, 354, 45427, 0, 354, 45427, 45427, 0, 354, 45427, 321, 354, 0, 354, 354, 354, 354, 0, 354, 354, 354, 354,
  354, 354, 354, 354, 47534, 354, 354, 354, 45427, 436, 45427, 441, 47556, 47556, 47576, 47556, 47556, 47556, 47576,
  47556, 47576, 47556, 47556, 47556, 47556, 47556, 47556, 47556, 47576, 47576, 47576, 47576, 47576, 47576, 47576, 47556,
  47556, 47576, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 155648, 0, 559, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88064, 0, 0, 0,
  88064, 0, 0, 0, 0, 274432, 0, 274432, 0, 0, 0, 0, 0, 579, 0, 274432, 414, 415, 47520, 47520, 47520, 47780, 47520, 454,
  455, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48857, 47561, 0, 0, 0, 0, 47520, 47520, 47520, 274848,
  47520, 47520, 47520, 47520, 454, 455, 0, 47561, 47790, 47561, 47561, 47561, 47561, 47561, 47561, 48406, 47561, 47561,
  252361, 47561, 47561, 47561, 47561, 47561, 47561, 48421, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 0, 0, 0, 0, 47520, 47520, 47520, 274889, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47520, 479, 480, 0, 482, 483, 0, 47561, 0, 4, 41199, 0, 0, 740, 0, 0, 0, 0, 0, 0, 1184, 0, 1185, 0,
  1186, 0, 1187, 0, 1188, 0, 0, 0, 0, 818, 740, 818, 0, 0, 45414, 45414, 45877, 45414, 45881, 45414, 45882, 45414,
  45414, 45414, 45414, 46116, 45414, 45414, 46119, 0, 0, 0, 0, 0, 0, 0, 0, 221184, 0, 0, 0, 0, 0, 0, 0, 841, 0, 0, 0,
  844, 0, 0, 0, 0, 0, 0, 849, 850, 0, 0, 853, 855, 0, 47960, 47520, 47520, 47963, 47520, 47520, 47970, 47520, 47520,
  47972, 47520, 47520, 47520, 47520, 48597, 47520, 47520, 48600, 47520, 184736, 47520, 217504, 47520, 47520, 47520,
  47520, 48831, 47520, 47561, 47561, 47561, 47561, 48836, 47561, 48838, 47561, 48840, 47561, 48025, 47561, 47561, 48033,
  47561, 47561, 48036, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48761, 47561, 305152, 0, 0,
  0, 48045, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  48533, 975, 0, 47561, 0, 0, 0, 0, 0, 0, 0, 983, 0, 749, 0, 751, 0, 0, 0, 0, 741, 0, 0, 0, 45414, 45414, 45414, 45414,
  45414, 45414, 45414, 45414, 45414, 45414, 258406, 45414, 45414, 753, 0, 755, 0, 0, 0, 995, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  139264, 0, 0, 0, 0, 0, 0, 0, 0, 1016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1039, 0, 0, 0, 1205, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 43008, 0, 45414, 46298, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 17454, 0, 0, 0, 0,
  0, 290816, 0, 0, 291558, 0, 0, 0, 0, 0, 0, 853, 0, 0, 48354, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 356768, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 348576,
  47520, 47520, 47520, 47520, 47520, 47520, 48390, 0, 0, 0, 0, 48393, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48530, 47561, 47561, 47561, 47561, 47561, 0, 0, 1345, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1215, 0, 0, 47520, 47520, 48512, 47520, 47520, 47520, 0, 0, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  48538, 47561, 47561, 47561, 47520, 0, 0, 0, 0, 48534, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47520, 0, 0, 0, 0, 0, 0, 0, 0, 47561, 0, 1330, 0, 0, 0, 0, 0, 0, 0, 1466, 0, 0, 0, 0, 0, 0, 45414, 45414,
  45414, 45414, 45414, 45414, 45414, 46294, 252262, 45414, 45414, 45414, 47520, 47520, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 48616, 47561, 47561, 47561, 47561, 47561, 233929, 47561, 47561,
  262601, 47561, 47561, 47561, 47561, 47561, 324041, 47561, 0, 0, 0, 337920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45414,
  45414, 45414, 45414, 45414, 0, 0, 0, 1598, 0, 0, 1601, 0, 0, 0, 0, 45414, 45414, 45414, 45414, 348518, 0, 0, 0, 0,
  747, 0, 749, 751, 0, 0, 753, 755, 0, 0, 0, 0, 0, 0, 67584, 0, 0, 0, 1, 8194, 3, 4, 0, 0, 0, 71680, 242, 0, 0, 0, 0, 0,
  0, 0, 296, 296, 296, 0, 23063, 0, 0, 0, 0, 348617, 47561, 47561, 47561, 47561, 0, 0, 1630, 0, 1632, 0, 0, 0, 0, 1636,
  0, 0, 0, 0, 790, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559, 0, 0, 0, 0, 516, 517, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 809, 0, 0, 0, 0,
  0, 47561, 47561, 47561, 48784, 47561, 48786, 47561, 47561, 47561, 0, 0, 0, 0, 0, 0, 0, 1445, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 250, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1226, 0, 0, 0, 0, 36864, 38912, 0, 0, 332, 0, 0, 0, 34816, 0, 0, 0, 0,
  0, 0, 1196, 0, 0, 0, 0, 0, 0, 0, 0, 0, 415744, 0, 415744, 0, 0, 0, 0, 0, 394, 398, 394, 398, 398, 398, 398, 394, 394,
  394, 394, 394, 394, 394, 394, 394, 398, 394, 394, 398, 47535, 394, 394, 394, 45428, 437, 45428, 442, 47557, 47557,
  47577, 47557, 47557, 47557, 47577, 47557, 47577, 47557, 47557, 47557, 47557, 47557, 47557, 47557, 47577, 47577, 47577,
  47577, 47577, 47577, 47577, 47557, 47557, 47577, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 529, 0, 0, 0, 296, 296, 296, 0,
  0, 0, 0, 0, 0, 0, 421888, 0, 0, 0, 0, 0, 0, 0, 0, 55671, 55671, 375, 1, 8194, 3, 4, 0, 0, 529, 0, 0, 159744, 0, 559,
  0, 0, 0, 0, 561, 0, 0, 0, 0, 0, 0, 1221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 65536, 65536, 65536, 65536, 566, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67584, 0, 583, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 256358,
  45414, 287078, 45414, 45414, 45414, 45414, 45886, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  45895, 45414, 45414, 45414, 45661, 45414, 45414, 45414, 0, 0, 0, 0, 256000, 0, 286720, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  358400, 0, 0, 0, 0, 0, 0, 47775, 47520, 47520, 47761, 47520, 454, 455, 0, 47561, 47791, 47561, 47561, 47561, 47561,
  47561, 256457, 47810, 287177, 47561, 47561, 47561, 47561, 47561, 47824, 47561, 47561, 47561, 47561, 47561, 47520, 479,
  480, 0, 482, 483, 0, 47561, 0, 4, 41199, 0, 0, 0, 741, 0, 0, 0, 0, 0, 277, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 796, 0, 0, 0,
  559, 0, 284672, 0, 0, 0, 0, 0, 749, 751, 0, 0, 753, 755, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86016, 0,
  86016, 86016, 0, 0, 855, 0, 47960, 47520, 47520, 47964, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 454, 455, 0, 47561, 47561, 47561, 47561, 47561, 47803, 47561, 47561, 48026, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 344521, 48046, 47561, 285129, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 48056, 48057, 47561, 47561, 47561, 47561, 47561, 47561, 373193, 47561, 47561,
  47561, 47561, 47520, 0, 0, 0, 0, 0, 0, 0, 0, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 753, 0, 755,
  0, 0, 0, 0, 996, 0, 0, 0, 0, 0, 1001, 0, 0, 0, 0, 0, 578070, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 266, 267, 0, 0, 0, 0, 0, 0,
  0, 301056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1458, 0, 0, 0, 0, 0, 0, 45414, 175126, 45414, 45414, 45414, 45414,
  45414, 46107, 45414, 45414, 45414, 46110, 45414, 45414, 45414, 45414, 46432, 45414, 46433, 45414, 346470, 45414,
  45414, 0, 0, 1381, 0, 0, 0, 0, 0, 47537, 0, 0, 0, 45414, 0, 45414, 0, 47537, 47537, 47579, 1064, 175144, 17454, 0,
  853, 0, 855, 47960, 47520, 47520, 175157, 47520, 47520, 47520, 47520, 47520, 454, 455, 0, 47561, 47561, 47561, 47561,
  47561, 229833, 47561, 47561, 913, 0, 915, 15252, 47561, 47561, 47561, 47561, 175210, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 48788, 47561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1446, 0, 0, 0, 1448, 0, 0, 0, 364544, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1343, 0, 0, 0, 0, 1192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1369, 1370, 0, 0, 0, 0, 0, 1208,
  0, 1210, 282624, 0, 0, 0, 0, 0, 0, 0, 0, 266240, 0, 0, 0, 0, 0, 0, 45414, 0, 0, 0, 0, 192512, 0, 0, 0, 0, 0, 208896,
  0, 0, 0, 0, 0, 0, 1336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 416140, 396, 0, 0, 416140, 396, 0, 0, 0, 0, 0, 45414, 45414, 45414,
  192870, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 46434, 45414, 45414, 45414, 0, 0, 0, 1382, 0, 45414,
  45414, 45414, 364902, 381286, 45414, 45414, 0, 0, 0, 0, 380928, 0, 17454, 0, 0, 0, 0, 241, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 111073, 111073, 111073, 111073, 0, 0, 0, 366592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20780, 20780, 20780,
  20780, 45414, 45414, 46430, 45414, 45414, 233830, 45414, 45414, 45414, 45414, 45414, 0, 233472, 0, 0, 0, 0, 0, 1361,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 306, 0, 0, 0, 0, 309, 0, 48487, 47520, 47520, 48490, 47520, 47520, 47520, 47520, 233888,
  47520, 262560, 47520, 47520, 47520, 47520, 344480, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 48502, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48602, 47520, 47520, 47520,
  47520, 47520, 47520, 324000, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 454, 455, 0, 47561, 47561, 47561, 47794, 47561, 47561, 47561, 47561, 48542, 268288, 0, 0, 0, 0, 0, 0, 0,
  188416, 0, 0, 200704, 217088, 0, 0, 0, 0, 246, 273, 274, 275, 276, 0, 0, 0, 0, 0, 0, 0, 333, 0, 0, 0, 0, 0, 0, 0, 0,
  1021, 0, 0, 0, 0, 0, 0, 1027, 0, 0, 0, 1465, 0, 0, 0, 329728, 0, 0, 0, 45414, 45414, 45414, 201062, 45414, 45414,
  45414, 45414, 46606, 45414, 0, 0, 1552, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48193, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 48221, 307616, 47520, 48223, 47520, 47520, 48225, 17454, 0, 47520, 47520, 47561,
  47561, 47561, 47561, 47561, 184777, 47561, 201161, 47561, 47561, 217545, 47561, 47561, 47561, 0, 47520, 48889, 47561,
  48890, 47520, 47561, 47520, 47561, 47520, 47561, 47520, 47561, 47561, 47561, 48678, 47561, 47561, 47561, 214570,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 356809, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 48692, 47561, 47561, 0, 0, 0, 0, 1593, 0, 0, 0, 0, 0, 0, 0, 578070, 75776, 578070, 0, 0, 75776, 0, 0, 0,
  48718, 47520, 47520, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 272841, 47561, 47561, 47561, 0,
  205216, 47520, 205257, 47561, 47520, 47561, 47520, 47561, 47520, 47561, 47520, 47561, 47561, 48730, 47561, 47561,
  47561, 303104, 0, 0, 0, 0, 0, 370688, 0, 0, 0, 0, 0, 414, 0, 0, 0, 0, 0, 0, 0, 0, 414, 454, 0, 409600, 0, 45414,
  47520, 204391, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48750, 47520, 47520, 47520, 0, 378880, 0, 496, 0, 0,
  378880, 47520, 47520, 47770, 47771, 47520, 47745, 47561, 204401, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  48760, 47561, 47561, 0, 0, 0, 0, 0, 415, 0, 0, 0, 0, 0, 0, 0, 0, 415, 455, 0, 0, 194560, 354304, 0, 0, 0, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 47520, 354720, 47520, 48865, 48866, 47561, 47561, 47561, 47561, 48871,
  48872, 0, 1770, 0, 47520, 47520, 47520, 47520, 47520, 48492, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 0, 0, 47561, 47561, 47561, 166345, 47561, 47561, 47561, 47561, 395, 0, 395, 0, 395, 395, 395, 395, 395, 395,
  395, 395, 395, 395, 395, 395, 47536, 395, 395, 395, 45429, 395, 45429, 395, 47536, 47536, 47578, 47536, 47536, 47536,
  47578, 47536, 47578, 47536, 47536, 47536, 47536, 47536, 47536, 47536, 47578, 47578, 47578, 47578, 47578, 47578, 47578,
  47536, 47536, 47578, 1, 8194, 3, 4, 41199, 41199, 0, 541, 0, 0, 544, 0, 0, 0, 0, 0, 0, 0, 552, 0, 0, 0, 0, 0, 1531, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 0, 0, 0, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 803, 0, 0, 0, 0, 803, 0, 0, 0, 0, 0, 0, 0,
  984, 1185, 986, 1186, 988, 1187, 990, 1188, 0, 855, 0, 47960, 47520, 47520, 47520, 47520, 47967, 47520, 47520, 47520,
  47520, 47520, 47520, 47520, 47520, 454, 455, 0, 47561, 47561, 47792, 47561, 47797, 47561, 47561, 47561, 47561, 47561,
  48030, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48425, 48426, 47561,
  975, 0, 47561, 0, 0, 978, 0, 0, 0, 0, 0, 0, 749, 0, 751, 0, 0, 0, 0, 804, 0, 0, 0, 0, 0, 0, 0, 811, 0, 0, 0, 0, 0,
  1032, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 368640, 0, 0, 0, 0, 0, 0, 0, 0, 1006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 61440,
  0, 0, 0, 0, 0, 0, 1030, 0, 0, 0, 0, 0, 0, 1036, 0, 1038, 0, 0, 0, 0, 0, 1538, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45414, 45414,
  45414, 45414, 45414, 45414, 45414, 45883, 0, 0, 0, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 45414,
  46109, 45414, 45414, 45414, 45414, 45414, 46117, 45414, 45414, 0, 0, 0, 0, 0, 1068, 0, 0, 45414, 45414, 46113, 45414,
  45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 0, 0, 321536, 0, 0, 0, 225280, 0, 0, 0, 47520, 47520, 48189, 47520,
  47520, 47520, 47520, 47520, 48194, 47520, 47520, 47520, 47520, 48198, 47520, 47520, 47520, 551, 0, 0, 0, 0, 0, 0,
  47520, 47520, 47520, 47520, 47772, 47520, 47520, 47520, 48217, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47520, 17454, 0, 0, 0, 0, 845, 0, 0, 0, 0, 845, 0, 0, 0, 780, 0, 853, 47561, 48243, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 48250, 47561, 47561, 47561, 47561, 47561, 48254, 0, 0, 0, 0, 45414, 45414, 45414, 45414,
  46292, 45414, 45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 47520, 48658, 47520, 47520, 47520, 47520, 48662,
  48401, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48058,
  47561, 47561, 47561, 0, 0, 0, 0, 1334, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133120, 0, 0, 0, 0, 47520, 47520, 47561,
  47561, 48611, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48541, 0, 0, 0, 0, 0, 0, 0,
  45414, 47520, 47520, 47520, 47520, 47520, 47520, 48747, 47520, 47520, 47520, 47520, 47520, 48014, 0, 913, 915, 0,
  15252, 47960, 47561, 47561, 47561, 47561, 47561, 47561, 48888, 0, 47520, 47520, 47561, 47561, 47520, 47561, 47520,
  47561, 47520, 47561, 47520, 47561, 47561, 47561, 47561, 48816, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 47520, 47520, 47520,
  47520, 48850, 47520, 47520, 0, 0, 36864, 38912, 0, 323, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 1348, 1349, 0, 0, 0, 0,
  0, 1355, 0, 0, 0, 0, 323, 0, 0, 0, 0, 323, 0, 0, 0, 0, 0, 0, 0, 0, 1020, 0, 0, 0, 0, 0, 0, 0, 1027, 47537, 47537,
  47537, 47579, 47537, 47579, 47537, 47537, 47537, 47537, 47537, 47537, 47537, 47579, 47579, 47579, 47579, 47579, 47579,
  47579, 47537, 47537, 47579, 1, 8194, 3, 4, 41199, 41199, 0, 210944, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 853, 855,
  0, 47960, 47520, 47520, 47520, 47520, 47520, 47520, 211360, 47520, 47520, 47520, 47520, 47520, 47520, 48205, 47520,
  47520, 47520, 47520, 47520, 47520, 48211, 47520, 47520, 47520, 47561, 47561, 47561, 47561, 211401, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48685, 48686, 47561, 47561, 47561, 0, 0, 294, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1545, 0, 46603, 0, 0, 36864, 38912, 294, 0, 0, 0, 0, 338, 34816, 338, 338, 338, 338, 0,
  0, 0, 0, 1017, 0, 0, 0, 0, 0, 1023, 0, 0, 0, 0, 1027, 0, 0, 0, 0, 0, 1222, 0, 0, 0, 0, 0, 0, 0, 315, 0, 316, 0, 0, 0,
  0, 316, 0, 0, 338, 0, 338, 338, 338, 338, 0, 338, 338, 338, 338, 338, 338, 338, 338, 45430, 45430, 338, 45430, 0, 338,
  45430, 45430, 0, 338, 45430, 338, 338, 338, 338, 338, 47538, 338, 338, 338, 45430, 338, 45430, 338, 47538, 47538,
  47580, 47538, 47538, 47538, 47580, 47538, 47580, 47538, 47538, 47538, 47538, 47538, 47538, 47538, 47580, 47580, 47580,
  47580, 47580, 47580, 47580, 47538, 47538, 47580, 1, 8194, 3, 4, 41199, 41199, 0, 0, 0, 405504, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 75776, 0, 0, 0, 47539, 47539, 47539, 47581, 47539, 47581, 47539, 47539, 47539, 47539, 47539, 47539, 47539,
  47581, 47581, 47581, 47581, 47581, 47581, 47581, 47539, 47539, 47581, 1, 8194, 3, 4, 41199, 41199, 0, 0, 611, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 611, 0, 0, 0, 0, 0, 0, 0, 622, 0, 414, 415, 47520, 0, 0, 788, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 800,
  559, 278528, 47561, 48063, 47561, 47561, 47561, 47561, 47561, 47561, 47520, 0, 969, 971, 0, 0, 0, 973, 975, 0, 47561,
  0, 0, 0, 0, 0, 0, 0, 0, 985, 749, 987, 751, 989, 753, 991, 755, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65536, 65536,
  0, 0, 0, 17454, 1072, 853, 1074, 855, 47960, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48367, 47520,
  47520, 47520, 47520, 47520, 47520, 47520, 48375, 47520, 47520, 913, 1125, 915, 15252, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 48264, 47561, 47561, 47561, 0, 482, 483, 0, 47561, 0, 4,
  41199, 0, 0, 0, 0, 0, 0, 382976, 0, 0, 0, 0, 1031, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 294, 295, 0, 0, 296, 774, 0, 0, 0,
  296, 296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1337, 0, 0, 0, 0, 0, 0, 0, 0, 227328, 0, 0, 0, 770, 771, 0, 0, 47520, 383392,
  47520, 47520, 47520, 47520, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48806, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 383433, 47561, 47561, 47561, 47561, 47561, 47520, 0, 969, 971, 0, 0, 0, 973, 753,
  0, 755, 0, 0, 0, 0, 0, 997, 0, 0, 0, 0, 0, 0, 0, 1602, 0, 0, 45414, 45414, 45414, 45414, 45414, 0, 311654, 45414,
  45414, 45414, 45414, 45414, 45414, 45414, 0, 0, 0, 0, 0, 0, 0, 0, 47520, 47520, 48848, 48849, 47520, 47520, 47520,
  47520, 47520, 47561, 47561, 311753, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 47561,
  47561, 47561, 48265, 47561, 47561, 47561, 47561, 47561, 47561, 47561, 222485, 231881, 47561, 47561, 47561, 47561,
  47561, 47561, 47561, 47561, 47561, 47561, 48628, 47561, 47520, 47561, 1526, 0, 0, 0, 1528, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 124928, 0, 0, 0, 0, 36864, 38912, 0, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 348, 0, 0, 411648, 0, 0, 411648, 0,
  0, 411648, 411648, 0, 0, 0, 0, 0, 0, 0, 411648, 0, 0, 0, 411648, 0, 0, 411648, 0, 0, 0, 0, 411648, 0, 411648, 0, 0, 0,
  0, 0, 0, 411648, 411648, 411648, 0, 0, 0, 0, 411648, 411648, 0, 0, 0, 0, 411648, 0, 411648, 411648, 0, 0, 0, 0, 261,
  262, 0, 264, 265, 0, 0, 0, 0, 0, 0, 0, 246, 246, 0, 0, 0, 0, 0, 0, 0, 248, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296,
  0, 0, 0, 0, 411648, 0, 411648, 0, 0, 0, 411648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92459, 92644, 92644, 92644, 0, 0,
  411975, 411975, 411648, 0, 411648, 0, 0, 0, 411975, 0, 0, 0, 0, 0, 0, 1362, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20780, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 261, 0, 262, 0, 0, 411648, 0, 0, 411648, 0, 0, 0, 411648, 411648, 0, 411648, 411648, 0, 0,
  0, 0, 0, 1740, 0, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 48495, 47520, 47520, 47520, 47520,
  47520, 0, 0, 0, 0, 411648, 0, 411648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47520, 48847, 47520, 47520, 47520, 47520, 47520,
  47520, 47520, 47983, 47520, 47520, 47520, 47520, 47520, 47520, 47520, 47992, 0, 0, 411648, 0, 0, 0, 411648, 411648,
  411648, 0, 1, 8194, 3, 4, 0, 0, 0, 0, 261, 262, 0, 264, 265, 0, 0, 0, 0, 0, 0, 169984, 416140, 396, 416140, 396,
  416140, 416140, 416140, 416140, 416140, 416140, 416140, 416140, 416140, 416140, 416140, 416140, 0, 416140, 416140,
  416140, 416140, 416140, 416140, 416140, 0, 0, 0, 0, 419840, 328, 328, 0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 0, 0, 0, 1455,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 141312, 0, 0, 0, 141312, 0, 0, 0, 0, 419840, 419840, 419840, 0, 0, 419840, 0, 0, 419840, 0,
  0, 0, 419840, 0, 0, 0, 419840, 419840, 419840, 1, 8194, 3, 4, 0, 0, 0, 419840, 0, 419840, 419840, 419840, 419840, 0,
  419840, 419840, 419840, 419840, 419840, 419840, 419840, 419840, 0, 419840, 419840, 419840, 419840, 419840, 419840,
  419840, 0, 0, 0, 0, 4096, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 311296, 0, 0, 4096, 4096, 4096, 0, 0, 4096, 0,
  4096, 4096, 0, 0, 4096, 4096, 0, 0, 0, 0, 1182, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1543, 0, 0, 0, 45414, 4096, 4096,
  4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 0, 4096, 4096, 4096, 4096, 4096,
  4096, 4096, 0, 0, 0, 0, 0, 0, 0, 4096, 0, 0, 4096, 4096, 4096, 0, 0, 0, 0, 0, 0, 272, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  25354, 0, 0, 0, 0, 0, 0
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  784, 835, 791, 800, 801, 797, 800, 808, 793, 805, 812, 816, 820, 824, 828, 832, 2240, 879, 2234, 879, 1132, 879, 839,
  847, 879, 2082, 873, 853, 937, 858, 862, 868, 879, 1138, 1914, 879, 2264, 2266, 1190, 872, 873, 1445, 888, 896, 896,
  918, 924, 878, 1129, 2277, 879, 1291, 841, 885, 873, 873, 874, 895, 896, 896, 901, 925, 879, 879, 905, 2265, 912, 872,
  873, 873, 916, 896, 896, 922, 929, 879, 879, 1293, 934, 873, 1448, 896, 939, 1452, 879, 1289, 1442, 873, 857, 963,
  879, 1671, 943, 873, 896, 1451, 1439, 873, 962, 1451, 947, 897, 1898, 1450, 1899, 951, 856, 1881, 891, 955, 959, 967,
  1433, 1231, 971, 975, 976, 980, 984, 985, 989, 993, 997, 1001, 1005, 1009, 1013, 1020, 1466, 879, 1274, 879, 879,
  1024, 879, 1029, 879, 879, 879, 879, 879, 879, 1033, 879, 879, 879, 879, 2015, 879, 879, 879, 879, 879, 879, 879, 879,
  879, 1399, 879, 879, 879, 879, 1841, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 1911, 879, 879,
  879, 879, 879, 879, 879, 879, 879, 879, 879, 1921, 879, 879, 879, 879, 879, 879, 879, 879, 1913, 879, 879, 879, 879,
  879, 1921, 879, 879, 879, 879, 1922, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 1704,
  2285, 1394, 1040, 879, 1637, 1051, 879, 1061, 1065, 1069, 1073, 1077, 1081, 1085, 1092, 1158, 1098, 879, 1099, 1103,
  1107, 1111, 1843, 1117, 1535, 1121, 1576, 2107, 879, 1966, 1419, 1682, 1043, 1237, 1126, 1144, 879, 1162, 1166, 879,
  1430, 1506, 1172, 879, 879, 1177, 1182, 879, 2330, 1187, 1194, 1521, 1200, 879, 1409, 1204, 1210, 879, 879, 879, 1178,
  1183, 2329, 2032, 1156, 1673, 1214, 879, 1464, 1224, 879, 879, 879, 1831, 879, 1153, 1228, 1272, 1315, 2088, 879, 879,
  1680, 2320, 2034, 1247, 2172, 1254, 879, 1260, 1266, 1270, 1939, 1278, 1597, 1284, 1297, 1302, 1644, 1946, 1947, 1308,
  1948, 1309, 1815, 2244, 1313, 1818, 1319, 1999, 879, 879, 1672, 879, 1472, 879, 879, 1323, 1327, 1335, 1339, 1343,
  1347, 1351, 1355, 1357, 1988, 879, 1482, 1629, 1361, 1960, 1804, 1367, 1851, 1371, 1375, 1379, 1385, 1389, 1393, 1671,
  879, 2167, 1619, 1398, 2195, 1403, 1407, 1414, 1929, 1418, 1978, 879, 1423, 879, 879, 879, 1381, 1590, 1362, 1427,
  1457, 1954, 906, 1461, 879, 1470, 880, 1476, 879, 879, 879, 1479, 1492, 2164, 1498, 1256, 843, 1505, 1972, 906, 1510,
  879, 879, 2291, 1532, 1517, 1525, 1135, 864, 1636, 1529, 879, 1748, 1492, 1548, 881, 1057, 849, 879, 1582, 1552, 1555,
  1054, 2050, 879, 1559, 1563, 1573, 1904, 1234, 1580, 1608, 1586, 1609, 2094, 1566, 1594, 1606, 1569, 1613, 1617, 879,
  1941, 879, 906, 1623, 1628, 1633, 1641, 1648, 1501, 1652, 1656, 1660, 1664, 1666, 1298, 1670, 1262, 1987, 1330, 2321,
  1677, 1687, 1691, 1695, 1699, 1828, 2170, 1703, 1708, 2101, 1712, 1088, 1713, 1717, 1173, 1189, 1731, 1721, 879, 1728,
  2017, 2021, 879, 1737, 879, 1742, 1140, 1624, 1331, 2287, 1886, 1733, 879, 1602, 1747, 2019, 879, 2129, 1738, 879,
  1743, 2297, 1752, 1205, 1683, 2040, 879, 1762, 2120, 879, 2308, 1408, 1410, 2188, 1905, 1206, 1769, 1122, 1773, 1778,
  1113, 879, 1783, 1588, 2289, 1787, 1793, 879, 1797, 1985, 1206, 1801, 1808, 1887, 1765, 1250, 1724, 2258, 1755, 2047,
  1513, 1487, 1287, 1488, 1812, 1825, 1047, 1485, 1043, 1046, 879, 879, 2056, 879, 879, 1838, 1847, 1147, 2070, 1855,
  1859, 1863, 1867, 1871, 1875, 1878, 1436, 1885, 879, 1891, 786, 1895, 2004, 1903, 1909, 1036, 879, 1016, 1918, 1927,
  1933, 2053, 1937, 1774, 1945, 2237, 1952, 1958, 1168, 1964, 879, 1243, 1970, 1976, 879, 2272, 1982, 1992, 879, 1997,
  787, 2003, 1959, 2008, 879, 879, 2012, 2253, 879, 879, 1834, 2026, 1993, 1779, 1821, 2038, 2081, 2044, 879, 1494,
  2063, 1408, 879, 2060, 2067, 879, 2074, 2078, 1538, 879, 2086, 2092, 1025, 2098, 2105, 2111, 908, 2245, 2115, 2119,
  1220, 2124, 2128, 1849, 2133, 1923, 2137, 2242, 1541, 2141, 2145, 1094, 1217, 2152, 2149, 2153, 2157, 1544, 1758,
  2161, 2176, 2180, 2183, 879, 2187, 879, 879, 2314, 2192, 2199, 2203, 2207, 2211, 2215, 2219, 2223, 2227, 2231, 879,
  879, 879, 2251, 2257, 2262, 2302, 879, 2270, 1196, 879, 879, 2276, 879, 2247, 879, 879, 879, 2281, 1453, 1554, 2328,
  2022, 879, 879, 879, 2295, 879, 879, 879, 1600, 879, 879, 1789, 930, 2301, 879, 1519, 879, 879, 1363, 879, 879, 879,
  879, 2295, 879, 879, 2306, 2312, 2328, 1554, 879, 879, 2318, 879, 879, 2246, 2319, 879, 2029, 2325, 879, 879, 1304,
  879, 879, 1280, 879, 2283, 1240, 879, 908, 879, 907, 879, 1150, 879, 908, 879, 2080, 2331, 879, 879, 879, 2328, 879,
  879, 879, 879, 879, 879, 879, 879, 879, 879, 879, 2446, 2502, 2512, 2512, 2341, 3290, 3321, 2346, 2959, 2961, 2961,
  2367, 2370, 3808, 2362, 2960, 2961, 2961, 2961, 2961, 2376, 2383, 2960, 2373, 2961, 2961, 2962, 2363, 2387, 2390,
  2400, 2404, 2408, 2412, 2411, 2416, 2419, 2393, 2423, 2396, 2427, 2431, 2434, 2438, 2452, 2441, 2444, 2448, 3317,
  2512, 3786, 2512, 2335, 3633, 3806, 2512, 3757, 3534, 3534, 2512, 2512, 2473, 3326, 3534, 3536, 2512, 2512, 2474,
  2458, 3501, 2512, 3181, 3183, 3185, 2480, 2480, 2480, 2569, 2557, 2485, 2512, 2512, 2512, 3867, 2512, 3682, 3685,
  2759, 3499, 3183, 3183, 3183, 3183, 3427, 3686, 2512, 2512, 2512, 2512, 2472, 3062, 3235, 3237, 3183, 3183, 3427,
  3429, 2480, 2480, 2579, 3182, 3338, 2480, 2480, 2480, 2480, 2512, 2480, 2568, 2571, 2561, 3925, 2512, 2512, 2512,
  2513, 2512, 2512, 3534, 3758, 2512, 3236, 3337, 2566, 2480, 2480, 2570, 2556, 2569, 2572, 2562, 2512, 4034, 3683,
  3686, 3684, 2512, 2512, 2512, 2519, 3500, 3183, 3183, 3183, 3428, 2480, 2480, 2567, 2572, 3534, 3759, 3182, 3183,
  3111, 3183, 3183, 3183, 2480, 2579, 2512, 3183, 3184, 2480, 2579, 3183, 3185, 2480, 3180, 3184, 2480, 2480, 2480,
  2578, 2481, 3185, 2576, 2576, 2675, 2612, 2619, 2673, 2644, 2644, 2644, 2644, 2630, 2624, 2634, 2649, 2655, 2622,
  2644, 2644, 2644, 2640, 2651, 2644, 2645, 2975, 2659, 2642, 2667, 2670, 2680, 2683, 3004, 2637, 2687, 2694, 2690,
  2698, 2713, 2717, 2701, 2736, 3001, 2721, 2978, 2725, 2729, 2733, 2704, 2512, 2512, 3765, 3794, 2606, 2512, 2512,
  2741, 3814, 2512, 2512, 2512, 2525, 2512, 3699, 3819, 3210, 2770, 2780, 4033, 2512, 2512, 3775, 3784, 3560, 2488,
  2492, 2512, 2512, 3799, 2512, 2512, 3800, 2512, 2742, 3101, 2499, 2798, 2512, 2512, 3862, 2512, 2512, 3866, 3864,
  2608, 2806, 2512, 2814, 2823, 2773, 2776, 2830, 2834, 2840, 2838, 2838, 2844, 2847, 2851, 2855, 2863, 2860, 2856,
  2867, 2868, 2868, 2868, 2872, 2875, 2878, 2881, 2512, 2512, 3885, 3612, 2517, 3120, 2512, 2512, 2524, 3096, 2489,
  3317, 2512, 2512, 2766, 3820, 2512, 2512, 3521, 3573, 3390, 2512, 3951, 3200, 2888, 2512, 2512, 2550, 3645, 2892,
  2512, 2512, 3507, 2920, 2512, 2512, 2512, 2551, 3826, 2512, 2969, 2512, 2512, 4032, 2512, 2470, 3212, 2512, 2473,
  3350, 2512, 2496, 2512, 2512, 2512, 3884, 2757, 2948, 2956, 2512, 2512, 4037, 2512, 2520, 2512, 3764, 2506, 2512,
  2757, 3040, 2512, 2512, 2737, 3560, 2892, 2512, 3855, 3016, 2580, 2966, 2512, 2512, 2595, 3830, 2998, 2512, 2512,
  2512, 2661, 3029, 2791, 2512, 2512, 3209, 3209, 2944, 2492, 2512, 2512, 3278, 2512, 2504, 2512, 2512, 2512, 3235,
  3780, 3008, 2512, 2512, 2737, 2512, 3015, 2512, 3021, 3788, 3027, 2512, 2512, 2512, 2662, 2512, 2512, 3482, 3023,
  2379, 3480, 2994, 3280, 2512, 2521, 3096, 2512, 2528, 3908, 3843, 2512, 3481, 2993, 2378, 3921, 2512, 3111, 2512,
  2603, 2676, 2931, 3524, 3778, 2512, 2512, 3762, 2512, 2512, 3764, 2512, 2512, 3765, 3558, 3111, 3480, 3922, 2512,
  2663, 2512, 3293, 3480, 3053, 2512, 2512, 2755, 2512, 2942, 3619, 2512, 2512, 2782, 3609, 3762, 2506, 2512, 3383,
  3922, 3112, 3919, 3923, 2512, 2512, 2754, 2765, 3051, 3923, 2512, 2512, 2783, 2512, 2506, 2512, 3384, 2512, 2742,
  2512, 2512, 3111, 3534, 3534, 3534, 3758, 3761, 3058, 2512, 2792, 2512, 4042, 4038, 3066, 2512, 2512, 2784, 2512,
  2901, 4040, 2512, 4038, 2512, 3086, 3392, 2512, 2512, 2793, 3028, 4038, 2512, 2507, 4041, 3100, 2517, 2352, 3424,
  3028, 2512, 2517, 3205, 3405, 3490, 2512, 2512, 3406, 3105, 3205, 3205, 3110, 3116, 3124, 3127, 3131, 3134, 3148,
  3151, 3138, 3141, 3156, 3156, 3154, 3145, 3156, 3160, 3161, 3161, 3161, 3161, 3165, 2512, 3173, 3882, 2512, 2512,
  2512, 2708, 3179, 2512, 3189, 3280, 3307, 3280, 2512, 3204, 3417, 3790, 3281, 3280, 3346, 3219, 2512, 2512, 2808,
  3233, 2512, 3771, 2512, 3897, 3226, 2512, 2512, 3898, 3226, 2512, 2512, 2512, 2761, 3028, 2512, 2512, 2512, 2790,
  3318, 3981, 2512, 3231, 3241, 3280, 2512, 2512, 2512, 2792, 2952, 3222, 2512, 2512, 3245, 3266, 2512, 2512, 2512,
  2942, 3322, 3271, 3262, 3285, 3491, 2512, 3047, 2512, 2792, 2982, 2512, 2521, 2584, 2512, 2512, 3664, 2512, 2512,
  3756, 3758, 3181, 3183, 3183, 3502, 3183, 3183, 3427, 2480, 2480, 2579, 2512, 2512, 2512, 2520, 3320, 2517, 3297,
  2593, 2544, 3327, 3267, 2512, 2794, 2512, 2512, 2747, 2512, 3866, 3344, 2512, 2512, 2808, 3254, 2476, 2599, 3285,
  2512, 2808, 4033, 2512, 2809, 3255, 2512, 2742, 2512, 3317, 2893, 2512, 2512, 3035, 2338, 2512, 2512, 2884, 3890,
  3318, 2512, 2802, 3312, 3433, 3437, 3447, 3331, 2512, 2512, 2512, 2990, 2475, 2599, 2349, 2512, 2894, 2512, 3033,
  2512, 3487, 2512, 3318, 2512, 2512, 2892, 3541, 2517, 2754, 2512, 2755, 2475, 3072, 2504, 2512, 2910, 3106, 2512,
  2899, 2905, 2512, 2512, 3894, 2512, 2512, 3916, 3213, 3936, 2512, 3934, 3488, 2512, 3319, 2800, 2512, 3487, 2512,
  3319, 2512, 2512, 3061, 3487, 2512, 3320, 3321, 3639, 3362, 2512, 3779, 3635, 3369, 2512, 2924, 3488, 2923, 2512,
  3639, 2819, 2512, 2929, 3513, 2936, 2817, 3370, 2512, 2512, 3034, 2355, 3368, 2512, 2512, 3487, 2512, 2512, 3034,
  2912, 2512, 3489, 3381, 2512, 2937, 3618, 2512, 2707, 2512, 2512, 3635, 2552, 2750, 2512, 3487, 2922, 3778, 2512,
  3368, 3635, 3033, 3388, 3371, 2925, 3397, 2512, 2512, 3036, 3174, 3607, 3611, 2512, 2512, 3205, 3211, 2512, 2512,
  2512, 3035, 2513, 2515, 2512, 3208, 2512, 2512, 2513, 2737, 3410, 3414, 3209, 2512, 2937, 3619, 2507, 2513, 3421,
  3698, 3696, 3440, 3443, 3461, 3464, 3451, 3454, 3469, 3469, 3467, 3458, 3469, 3473, 3474, 3474, 3474, 3474, 3478,
  2512, 2952, 2512, 2512, 2512, 3111, 2512, 2512, 2512, 3486, 3495, 2512, 2942, 2490, 2512, 2512, 2512, 2590, 2786,
  2512, 2512, 3169, 3506, 2512, 2760, 3511, 2512, 3518, 3028, 3549, 3528, 2615, 2512, 3540, 3553, 2512, 2512, 2512,
  3119, 3564, 3547, 2512, 3279, 2951, 2512, 2512, 2512, 3206, 3974, 2512, 2512, 3761, 2512, 3568, 3584, 2512, 2984,
  2512, 3570, 2512, 3577, 3592, 2512, 3011, 3075, 2512, 3635, 3321, 3581, 3590, 3280, 2512, 2512, 2512, 3597, 3032,
  2512, 2512, 3593, 2512, 2512, 2512, 3354, 2512, 4038, 3490, 2512, 3031, 2512, 2756, 2512, 2522, 3095, 3635, 3623,
  3280, 2512, 3031, 2512, 3212, 2512, 3372, 2512, 3373, 3646, 2512, 2512, 2512, 3356, 3571, 2512, 2512, 2512, 3357,
  2358, 2512, 2512, 3077, 3374, 3374, 2512, 3635, 2511, 2522, 2986, 2512, 2512, 3570, 3643, 2512, 2512, 3030, 3635,
  3375, 3321, 2512, 3046, 2512, 3979, 3650, 2512, 2512, 3572, 2742, 2512, 3799, 2512, 3085, 2507, 4041, 2512, 3090,
  4040, 2512, 2341, 3290, 2894, 2512, 2893, 2512, 3167, 3545, 2512, 2943, 2491, 2512, 2535, 3875, 3880, 2512, 4034,
  3668, 2512, 3175, 2512, 2512, 2512, 4042, 2512, 4034, 2512, 4040, 2512, 2512, 3193, 2512, 2758, 3257, 2626, 2932,
  2512, 3679, 3690, 3693, 3703, 3732, 3730, 3727, 3707, 3711, 3720, 3720, 3718, 3715, 3724, 3736, 3737, 3737, 3741,
  3737, 3745, 3748, 2512, 3180, 3183, 3183, 3635, 2512, 2512, 2512, 3372, 3572, 3357, 3208, 2512, 4040, 3754, 2512,
  3586, 2512, 3182, 3183, 3184, 2480, 3769, 2512, 2512, 2512, 3488, 2512, 3833, 3317, 2512, 2512, 3208, 2512, 2512,
  2512, 2532, 3017, 3798, 3804, 2512, 3207, 2512, 2512, 2512, 2527, 3247, 3812, 2512, 2512, 3251, 3261, 2512, 3653,
  3818, 2915, 2512, 3638, 2512, 2512, 3256, 2512, 4042, 3403, 3669, 2512, 4041, 2512, 2512, 3081, 2901, 3824, 2895,
  2512, 2512, 3304, 2512, 2516, 3659, 2512, 2512, 2512, 3491, 2512, 3314, 2512, 2512, 3334, 2512, 3837, 3675, 2512,
  2512, 3342, 2512, 3846, 3853, 2512, 2512, 3364, 3344, 3849, 3819, 2916, 2512, 3209, 3634, 2512, 2512, 2512, 3112,
  2914, 2938, 3636, 2512, 2512, 4034, 3668, 4039, 2512, 2504, 2512, 3824, 2742, 2512, 2514, 2512, 2595, 3859, 2512,
  3315, 2883, 3558, 3871, 2512, 3227, 2512, 2512, 2512, 3983, 3760, 2512, 2512, 2512, 3318, 2587, 2509, 2512, 2760,
  2512, 2524, 2512, 3280, 2507, 2512, 3383, 3922, 3585, 2894, 2512, 2512, 3373, 2512, 3889, 3316, 3313, 3317, 2512,
  2893, 2512, 3069, 2460, 2512, 2916, 2512, 3663, 2512, 2512, 3637, 2527, 2597, 3300, 2503, 2512, 2512, 3215, 2510,
  2512, 2509, 3635, 2462, 3673, 3840, 3358, 4041, 2505, 3289, 2908, 2742, 2512, 2516, 2512, 2512, 2512, 3498, 2883,
  3945, 2512, 2512, 3482, 3054, 3214, 3276, 2512, 2512, 3488, 2923, 3943, 3274, 2508, 2512, 3280, 2512, 3256, 2511,
  3638, 2512, 2512, 3514, 2512, 3903, 2512, 3288, 3292, 2525, 3971, 2512, 3213, 3198, 2512, 2512, 2512, 3572, 3638,
  2512, 3902, 2505, 3977, 2512, 2512, 2512, 3605, 2525, 3971, 2512, 3196, 3907, 2512, 2512, 3912, 3930, 2512, 2512,
  2526, 3929, 2504, 3924, 2759, 2512, 3599, 2759, 2758, 2512, 2524, 3935, 2512, 3599, 2759, 2759, 2521, 2512, 3599,
  2759, 2512, 3311, 3046, 2512, 2810, 3256, 2512, 2743, 2512, 2512, 3044, 2512, 3600, 2825, 4033, 2521, 3601, 3599,
  2512, 2826, 3093, 3940, 3940, 4034, 2512, 2512, 2512, 3631, 4035, 4036, 2538, 2512, 3312, 2760, 3490, 2512, 3961,
  2521, 3682, 3636, 2538, 2547, 2538, 2512, 3961, 3399, 2541, 3955, 3959, 2972, 3968, 3990, 3993, 3965, 3987, 3997,
  4010, 4009, 4009, 4007, 4001, 4005, 4014, 4015, 4019, 4015, 4015, 4022, 4026, 4029, 2512, 3313, 2466, 2512, 2342,
  3291, 2512, 2456, 2759, 2512, 2512, 4039, 2512, 2512, 2512, 2706, 2785, 2512, 3377, 2512, 2512, 3531, 3853, 2522,
  2512, 2512, 2512, 3657, 2518, 3393, 2512, 2512, 3534, 3534, 3534, 3534, 2512, 3320, 2512, 2512, 3556, 3876, 2708,
  2512, 2512, 2512, 3750, 3376, 2512, 2512, 2523, 2512, 2517, 2512, 2512, 2517, 2663, 2512, 2512, 2517, 4041, 2513,
  2709, 2512, 2512, 3616, 3634, 2512, 3320, 2512, 3761, 2512, 2511, 2523, 2512, 2512, 3635, 3627, 2519, 3318, 2512,
  2512, 3635, 3949, 2706, 2785, 2512, 2512, 2512, 3763, 2512, 2518, 2512, 2512, 3763, 2512, 2512, 2512, 3761, 2512,
  2512, 1082130432, 8388608, 8388608, 8388608, 0, 33554432, 0, -2147483648, 524288, 16384, 134217728, 16777728,
  16781312, 276824064, 8388608, 67108864, -2147483648, 0, 2, 8389120, 8192, 8388608, 33554432, 0, 4, 524288, 1048576,
  553648128, 553648128, -2130706432, -2130706432, 16777216, 16777216, 16784896, -2130706432, 16777216, 16777216,
  -2130706432, 16777216, 16777216, 1122304, 16777216, 16777216, 16777216, 33554432, 536870912, 0, 0, 16777216, 16777218,
  269639680, 1351680, 16777216, 16777216, 16777218, 16777218, 2097152, 18874368, 150994946, 4194432, -1392508926,
  754974722, 4194304, 4194432, 4194496, 18874368, 754974722, 150994946, 18878464, 555745280, 754974722, 150994946,
  555745280, 754974722, 150994946, 754974722, 150994946, 150994946, 150994946, 150994946, 754974722, 218103810,
  218103810, 754974722, 218103810, 150994946, 754974722, 218103810, 754974722, 757071874, -1392508926, 757071874,
  12583040, 20971648, 12582912, 20971712, 20971648, 20971712, 557842560, 20971648, -2126512000, 20971648, 20971648,
  -2143281536, -2126504256, -2126504256, -2126504254, -2126504256, -2126504256, 759169154, -1992286526, 4, 8, 16, 32,
  524288, 524288, -2126504256, -2126504256, -2126504256, -2126504256, 256, 256, 512, 4096, 1572864, 8388608, 0, 0,
  -2147483648, 524296, 33554432, 33554432, 3072, 3584, 16384, 1056768, 0, 0, 1, 2, 28, 384, 512, 1024, 4194368, 4194368,
  4194368, 4194368, 0, 4194368, 0, 32, 524288, 16777216, 67108864, 134217728, 268435456, 1073741824, 0, 0, 33554432,
  33554432, 3072, 2048, 8192, 262144, 524288, 1073741824, -2147483648, 0, 0, 0, -2147483648, 0, 0, 32, 0, 0, 0, 0, 1, 0,
  0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 6, 64, 128, 512, 0, 1048576, 8192, 0, 6, 192, 256, 256, 0, 0, 8, 8, 2, 28, 128, 1024, 0,
  1280, 0, 8, 16, 16384, 32768, 8388608, 4224, 0, 4288, 4288, 3072, 4288, 4288, 4288, 4194368, 0, 192, 4194368, 4194368,
  4194368, 4194304, 4224, 4224, 4224, 4288, 4288, 4194304, 4194368, 4194304, 4194368, 0, 0, 0, 1792, 8, 2048, 268435456,
  536870912, 1073741824, -2147483648, 0, 8, 16, 67108864, 536870912, 0, 0, 256, 512, 6144, 65536, 131072, 1572864, 0,
  268435456, 536870912, 0, 8, 2048, 0, 2048, 8320, 16, 16, 20, 48, 0, 0, 318767104, 80, 528, 262160, 524304, 1048592,
  1048592, 16, 16, 0, 134234112, 32, 16, 16, 16, 131088, 20, 16, 48, 16, -164575404, -164625872, 20, 16, 16, 17, 16, 16,
  16, 16, 17, 16, 24, 560, 48, 524304, 16, 1049104, 528, 1572880, 524304, 16, 1049136, 0, 2, 4096, 1073741824,
  -2147483648, 0, 16, 16, 165675008, 528, 16, 528, 1048592, 268435472, 16, 16, 2, 536936448, 0, 528, 528, 1049136,
  1049136, 0, 16, -164625872, -164575404, -164624592, -164575403, -164624528, -164624528, -164624528, -164624464,
  -164624528, -164624528, -164624528, -164575403, -164575376, -164575376, -164575376, -164575372, -164575372,
  -164575372, -164313228, -26200268, 0, 0, 1, 16, 64, 0, 0, -164313232, -164100176, -164575372, -164313228, -164100172,
  0, -164575372, -164313228, 16, 20, 16, 112, 140513284, 140521492, 140571932, 140571932, 140571964, 140571932,
  140571932, 140571932, 141620508, 140571964, 140571933, -164575372, 0, 0, 0, 2048, 16, 65536, 0, 0, 0, 3456, 0, 262144,
  524288, 0, 8, 4096, 1048576, 16, 131072, 0, 0, 0, 4096, 0, 0, 0, 32, 2048, 24, 0, 0, 0, 8320, 138412032, 0, 0, 8192,
  134217728, 2048, 1409449984, 536870912, 0, 536870912, 0, 239075328, 0, 0, 1, 64, 0, 0, 0, 109051904, 0, 4194304, 0, 0,
  0, 16384, 65536, 33554432, 524288, 1073741824, 0, 0, 2, 16, 2048, 131072, 2048, 1090519040, 0, 0, 2, 512, 1024, 2048,
  10368, 8192, 8192, 0, 12, 16, 256, 4096, 1572864, 1090519040, 32, 0, 0, 4, 64, 0, 553648128, 536870912, 553648128,
  -2147483640, 553648128, 553652224, 558370848, 554176544, 557323264, 3146768, 554177568, 557323264, 557323264,
  554177568, 3146768, 554177568, 137364496, 554177568, 554177568, 554177568, 1546814480, 554177568, 556274720,
  557323296, 556274721, 557323296, 557323312, 557323312, 557323312, 557323312, 554185889, 569906944, 557323312,
  557323312, 554185889, 557323312, 557323312, 557325360, 603543296, 603543296, 603543296, 603543296, 603543296,
  603543300, 603543300, 603543300, 603543301, 603543300, 603543300, 603543301, 603543300, 603543344, 603543332, 0, 0, 6,
  128, 256, 5120, 0, 5120, 557318144, 3145728, 0, 0, 0, 65536, 0, 0, 0, 472907776, 1073741824, 0, -2147483648, 0,
  556269568, 557318144, 13440, 0, 16, 0, 262144, 8192, 8388608, 0, 0, 230, 0, 0, 0, 5888, 569901056, 0, 0, 8, 1048576,
  0, 0, 134217728, 0, 7168, 0, 0, 16, 16, 32, 603455488, 0, 0, 0, 131072, 0, 0, 32768, 131072, 16777216, 67108864,
  134217728, 4718592, 0, 0, 1024, 4, 524288, 1048576, 0, 1024, 4096, 3670016, 553648128, -2130706432, 16777216,
  16777216, 16777216, 16777216, 16777472, 4096, 7864320, 8388608, 553648128, 8, -2147483648, 0, 16, 8960, 16, 16, 16,
  21, 21, 53, 117, 65536, 587202560, 0, 0, 16, 32768, 134217728, 0, 1792, 4096, 16384, 65536, 2097152, 4194304, 8388608,
  16777216, 7864320, 8388608, 587202560, 0, 16, 536936448, 16, -164575404, -164625872, 48, 3670016, 16777216, 536870912,
  0, 24, 1024, 8192, 2621440, 3670016, 0, 0, 0, 213504, 768, 4096, 3670016, 4194304, 8388608, 16777216, 65536, 33554432,
  0, 0, 0, 524288, 1048576, 0, 0, 0, 262144, 8192, 2, 4096, 2097152, 16777216, 536870912, 16384, 33554432, 0, 0, 32,
  134217728, 0, 768, 4096, 16384, 2097152, 16777216, 33554432, 0, 512, 4096, 16777216, 0, 28, 128, 1572864, 0, 4096,
  16384, 16777216, 0, 28, 384, 4096, 131072, 1572864, 8388608, 67108864, 0, 0, 32768, 268435456, 0, 131072, 67108864,
  268435456, 0, 131072, 268435456, 1073741824, 0, 0, 268435456, -2147483648, 0, 64, 0, 64, 2048, 4096, 536870912,
  262144, 0, 8192, 0, 2048, 262144, 0, 33554432, 0, 0, 8389120, 0, 0, 0, 2097152, 0, 0, 8388608, 4194304, 2, 64, 524288,
  4194304, 0, 2, 69206016, 0, 69206016, 69222400, 69208064, 134217760, 69208064, 69208080, 69225490, 69225490,
  891472978, 891472978, 354470930, 822247488, 354470930, 830636096, 891341906, 891472978, 891472978, 830636098,
  891735122, -1254372129, 891472978, 891472978, 822247488, 354470930, 891472978, 822255680, 354470930, 891472978,
  891735122, 891472978, 891472978, 891472978, 891472978, 895667282, -172236833, -172236833, -172236833, -172236833,
  -172236833, -172236833, 0, 0, 56, 3328, 8192, 131072, 2, 8388608, 0, 0, 4194304, 8388608, 19456, 0, 0, 0, 4194304,
  4194304, 4194304, 4194304, 4194368, 4194368, 82, 183296, 2097152, 352321536, 0, 52224, 352321536, 0, 64, 6144,
  536870912, 0, 0, 554172416, 0, 172032, 0, 0, 0, 8388608, 0, 0, 0, 32768, 0, 0, 0, 64, 6144, 2097152, 3670016,
  352321536, -1610612736, 0, 64, 131072, 536870912, -536870912, 0, 0, 0, 12582912, 18, 64, 1024, 2048, 0, 0, 128, 128,
  128, 4194304, 16384, 131072, 2097152, 67108864, 0, 393216, 0, 0, 198, 2341376, 31, 64, 128, 1024, 2048, 16384, 0, 0,
  0, 1049600, 2048, 16384, 65536, 131072, 3670016, 3670016, 67108864, 536870912, -2147483648, 0, 64, 384, 1536, 6144,
  65536, 2097152, 536870912, 0, 0, 536870912, 0, 0, 0, 445440, 8388608, 67108864, 536870912, -2147483648, 16384,
  134217728, 32, 4096, 0, 16, 0, 16, 16, 1024, 2048, 131072, 2097152, 33554432, 536870912, 0, 131072, 536870912, 0, 64,
  163840, 285212672, 0, 67108864, 0, 0, 0, 33554432, 1073741824, 0, 0, 0, 16, 0, 0, 0, 31, 128, 2048, 65536, 131072,
  1572864, 1572864, 67108864, -2147483648, 0, 64, 524288, 4194304, 192, 192, 192, 64, 384, 512, 6144, 8388608, 0, 0,
  223, 248832, 128, 131072, 1572864, -2147483648, 2, 512, 0, 0, 256, 1024, 1048576, 0, 16, 1572864, 0, 0, 384, 1536, 8,
  256, 4096, 1048576, 0, 0, 8, 16, 0, 0, 8, 32, 0, 8, 1048576, 0, 4096, 0, 4096, 16777216, 0, 134217728, 0, 8,
  -2147483648, 0, 0, 512, 8192, 8, 0, 8, 0, 256, 2, 524292, 1048576, 0, 0, 512, 262144, 0, 512, 524292, 262144, 1048576,
  4194304, 67108864, 134217728, 0, 82, 536870912, 183296, 0, 67108864, 512, 16384, 16384, 262144, 4194304, 4194304, 192,
  192, 64, 4194368, 262144, 16777216, 128, 268435456, 268468224, 67109888, 0, 67109888, 67109888, 75498496, 109052928,
  109194552, 109194552, 109186336, 67109888, 75498496, 67109888, -1073737726, 33712440, 109186336, 50473272, 109194528,
  109194544, 109194552, 318941496, 109194553, 780332344, 109194552, 109194552, 33728824, 109186336, 109194552, 33696056,
  109186336, 109194552, 109194553, 109194552, 109194552, 109194552, 109194552, 109194680, 782495096, 782495096,
  782495096, 782495096, 782495096, 782495096, 0, 0, 768, 4096, 16384, 65536, 75497472, 0, 0, 0, 134217728, 0, 0, 0,
  67108864, 2, 4096, -1073741824, 0, 128, 128, 4194304, 4194304, 4194304, 0, 4194304, 109051904, 0, 0, 0, 137363456,
  3328, 131072, 0, 0, 22272, 65536, 603455488, 56, 2304, 8192, 163840, 335544320, 536870912, 0, 12, 16, 1048576,
  50331648, 0, 32, 0, 192, 6144, 2097152, 2097152, 2097152, 2097152, 134217728, 0, 57, 0, 0, 0, 201326592, 24576,
  163840, 243269632, 536870912, 0, 0, 24576, 0, 120, 2326528, 536870912, 0, 198, 256, 512, 8192, 32768, 131072, 262144,
  120, 3328, 24576, 2326528, 24, 8192, 0, 0, 98304, 0, 0, 0, 553648128, 24, 1024, 24576, 32768, 24, 64, 1024, 24576, 16,
  0, 0, 262144, 268435456, 98304, 2097152, 8388608, 201326592, 536870912, 0, 0, 0, 16384, 0, 4, 64, 2048, 0, 0, 8, 16,
  64, 16384, 32768, 4194304, 16777216, 67108864, 268435456, 0, 0, 0, 32768, 16777216, 67108864, 268435456, 1073741824,
  0, 16, 16384, 32768, 201326592, 16, 16384, 98304, 201326592, 0, 32768, 16777216, 268435456, 0, 0, 0, 8, 0, 0, 0, 12,
  8, 16, 98304, 134217728, 536870912, 0, 0, 8, 16, 32768, 0, 198, 256, 2341376, 16, 98304, 0, 0, 196608, 0, 0, 131072,
  67108864, 0, 0, 1024, 1048576, 8388608, 0, 0, 256, 134234112, 0, 0, 458752, 0, 16, 32, 268697600, 0, 256, 256, 256,
  4096, 4096, 4096, 0, 0, 65792, 0, 65792, 65792, 65792, 1, 262144, 262144, 0, 0, 0, 100663296, 65792, 65792, 197376,
  197376, 1125123072, 16974592, 1124073504, 16974592, 1090716416, 1090716416, 1090716416, 1124073504, 1090716416,
  -956062842, 1124270848, 1124270848, 1090716416, 1124270848, 1124270848, 1124270848, 1124270848, 1124270848,
  1191379712, 1258504960, 1191379712, 1124073472, 16974592, 1191379712, 1124073472, 197376, 1191379712, 1191379712,
  197376, 1392968448, -412894266, -412894266, -412894266, -412894266, -412894234, -412894234, -412894234, -412894234,
  -412894266, -412894266, -412894234, -412894266, -412894266, 0, 0, 1048576, 1048576, 1049600, 16, 0, 0, 2097152,
  2097152, 2097152, 0, 0, 0, 128, 0, 0, 0, 134, 0, 197120, 0, 0, 6291456, 0, 0, 50331648, 1073741824, 0, 256, 4096, 0,
  0, 4096, 0, 16777216, 0, 0, 8388608, 16777216, 536870912, 0, 66, 0, 256, 238080, 117440512, -1073741824, 184549376, 0,
  0, 0, 1073741824, 0, 459264, 318767104, 0, 0, 16777218, 16777472, 16777472, 7680, 658505728, 0, 0, 0, 163577856, 0,
  658505728, -1073741824, 0, 0, 0, 10368, 262144, 268435456, 0, 0, 335544320, 536870912, 196608, 100663296, 1073741824,
  0, 256, 197120, 117440512, 196608, 100663296, -1073741824, 0, 256, 134234112, 32, 32, 0, 0, 198, 6144, 2097152,
  4194304, 100663296, 536870912, 4194304, 536870912, 0, 0, 469762048, 2621440, 196608, 33554432, 1073741824, 0, 384,
  4096, 8388608, 0, 0, 384, 512, 4096, 196608, 33554432, 1073741824, -2147483648, 512, 6144, 8192, 32768, 196608,
  196608, 2097152, 4194304, 33554432, 0, 0, 64, 32768, 16777216, 256, 512, 65536, 131072, 33554432, 256, 512, 65536, 0,
  479, 253440, 12058624, 352321536, 0, 1048576, 512, 0, 0, 512, 6144, 536870912, -2147483648, 0, 0, 1048576, 512,
  -2147483648, 6, 512, -2147483648, 0, 768, 4096, 2097152, 16777216, 0, 0, 0, 1048576, 0, 512, 2048, 4096, 536870912, 0,
  4, 64, 2048, 4096, 0, 0, 64, 64, 64, 64, 128, 256, 512, 65536, -2147483648, 32, 256, 4096, 0, 558366720, 0, 0, 4096,
  8960, 8960, 264, 2, 256, 0, 256, 0, 272, 3072, 6160, 16, 16, 16, 128, 512, -2147483648, 0, 512, 262144, 134217728,
  4096, 0, 16, 0, 18, 0, 0, 64, 98304, 272, 3076, 6160, 272, 16, 4112, 4112, 16, 16, 4112, 3072, 6160, 3074, 6160, 7440,
  81, 7184, 7184, 7440, 7440, 7184, 7440, 7184, 7184, 7184, 7184, 3074, 7440, 81, 81, 81, 81, 337, 81, 337, 81, 81, 337,
  4177, 81, 81, 337, 7505, 7249, 0, 0, 2048, 0, 0, 0, 256, 0, 0, 0, 512, 0, 0, 0, 1024
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "EOF",
  "PragmaContents",
  "DirCommentContents",
  "DirPIContents",
  "CDataSectionContents",
  "Wildcard",
  "URIQualifiedName",
  "URILiteral",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "PITarget",
  "CharRef",
  "NCName",
  "QName",
  "S",
  "S",
  "CommentContents",
  "'!'",
  "'!='",
  "'""'",
  "'#'",
  "'#)'",
  "'$'",
  "'%'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'<![CDATA['",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'NaN'",
  "'['",
  "']'",
  "']]>'",
  "'allowing'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'binary'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'context'",
  "'copy-namespaces'",
  "'count'",
  "'decimal-format'",
  "'decimal-separator'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'digit'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'end'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'full'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'group'",
  "'grouping-separator'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'infinity'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'minus-sign'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'namespace-node'",
  "'ne'",
  "'next'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'only'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'pattern-separator'",
  "'per-mille'",
  "'percent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'previous'",
  "'private'",
  "'processing-instruction'",
  "'property'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'sliding'",
  "'some'",
  "'stable'",
  "'start'",
  "'strict'",
  "'strip'",
  "'stylesheet'",
  "'switch'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'tumbling'",
  "'type'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'when'",
  "'where'",
  "'window'",
  "'xquery'",
  "'zero-digit'",
  "'{'",
  "'{{'",
  "'|'",
  "'||'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer)
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 6)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 6
    let $i0 := $t * 1792 + $state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[6 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[12 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    subsequence($state, $p:e3),
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
        element TOKEN {$content}
      else
        element {$name} {$content}
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 24) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 36) then                           (: ('(' ':') :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      subsequence($state, $p:l2, $p:e2 - $p:l2 + 1)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    subsequence($state, $p:lk + 1, $p:l2 - $p:lk - 1),
    $match,
    0, $match[3], 0,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      subsequence($state, $p:l3, $p:e3 - $p:l3 + 1)
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    subsequence($state, $p:lk + 1, $p:l3 - $p:lk - 1),
    $match,
    subsequence($state, $p:e3 + 1)
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      subsequence($state, $p:e2 + 1)
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(80, $input, $state)          (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 49) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 25) then                      (: CommentContents :)
            let $state := p:shift(25, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(36, $input, $state)                 (: ('(' ':') :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(49, $input, $state)                 (: (':' ')') :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(24, $input, $state)            (: S^WS | ('(' ':') :)
  let $state :=
    if ($state[$p:l1] = 24) then                            (: S^WS :)
      let $state := p:shift(24, $input, $state)             (: S^WS :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Comment($input, $state)
      return $state
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "QueryBody", $count)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-QueryBody($input, $state)
  return p:reduce($state, "MainModule", $count)
};

(:~
 : Parse the 1st loop of production MainModuleSequence (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(81, $input, $state)         (: EOF | S^WS | ('(' ':') | ';' :)
    let $state :=
      if ($state[$p:l1] = 52) then                          (: ';' :)
        let $state := p:lookahead2W(229, $input, $state)    (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | ';' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] = 1                                 (: EOF :)
       or $state[$p:lk] = 308                               (: ';' EOF :)
       or $state[$p:lk] = 13364) then                       (: ';' ';' :)
        $state
      else
        let $state := p:shift(52, $input, $state)           (: ';' :)
        let $state := p:lookahead1W(223, $input, $state)    (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:l1] = 198) then                     (: 'xquery' :)
            let $state := p:lookahead2W(174, $input, $state) (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                                '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                                '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                                'castable' | 'div' | 'encoding' | 'eq' | 'except' |
                                                                'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                'le' | 'lt' | 'mod' | 'ne' | 'or' | 'to' | 'treat' |
                                                                'union' | 'version' | '|' | '||' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 28102                    (: 'xquery' 'encoding' :)
                or $state[$p:lk] = 49862) then              (: 'xquery' 'version' :)
            let $state := p:parse-VersionDecl($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MainModule($input, $state)
        return p:parse-MainModuleSequence-1($input, $state)
};

(:~
 : Parse MainModuleSequence.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MainModule($input, $state)
  let $state := p:parse-MainModuleSequence-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 52) then                       (: ';' :)
      let $state := p:shift(52, $input, $state)             (: ';' :)
      return $state
    else
      $state
  return p:reduce($state, "MainModuleSequence", $count)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(69, $input, $state)           (: S^WS | ('(' ':') | 'option' :)
  let $state := p:shift(152, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  return p:reduce($state, "OptionDecl", $count)
};

(:~
 : Parse FunctionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EnclosedExpr($input, $state)
  return p:reduce($state, "FunctionBody", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(133, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(111, $input, $state)          (: S^WS | ('(' ':') | 'external' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:parse-FunctionBody($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(114, $input, $state)            (: 'external' :)
      return $state
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(193, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 51) then                            (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(114, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(30, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse the 1st loop of production AnnotatedDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(140, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
    return
      if ($state[$p:l1] != 32                               (: '%' :)
      and $state[$p:l1] != 165) then                        (: 'private' :)
        $state
      else
        let $state := p:parse-Annotation($input, $state)
        return p:parse-AnnotatedDecl-1($input, $state)
};

(:~
 : Parse AnnotatedDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnnotatedDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:parse-AnnotatedDecl-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 193) then                           (: 'variable' :)
      let $state := p:parse-VarDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionDecl($input, $state)
      return $state
  return p:reduce($state, "AnnotatedDecl", $count)
};

(:~
 : Parse VarDefaultValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDefaultValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "VarDefaultValue", $count)
};

(:~
 : Parse the 1st loop of production CatchErrorList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(123, $input, $state)        (: S^WS | ('(' ':') | '{' | '|' :)
    return
      if ($state[$p:l1] != 202) then                        (: '|' :)
        $state
      else
        let $state := p:shift(202, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(212, $input, $state)    (: Wildcard | URIQualifiedName | QName^Token | S^WS |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        let $state := p:parse-NameTest($input, $state)
        return p:parse-CatchErrorList-1($input, $state)
};

(:~
 : Parse CatchErrorList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchErrorList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-NameTest($input, $state)
  let $state := p:parse-CatchErrorList-1($input, $state)
  return p:reduce($state, "CatchErrorList", $count)
};

(:~
 : Parse CatchClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CatchClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(15, $input, $state)            (: 'catch' :)
  let $state := p:shift(86, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(214, $input, $state)          (: Wildcard | URIQualifiedName | QName^Token | S^WS | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '(' :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(38, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CatchErrorList($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CatchClause", $count)
};

(:~
 : Parse TryTargetExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryTargetExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "TryTargetExpr", $count)
};

(:~
 : Parse TryClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: 'try' :)
  let $state := p:shift(186, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TryTargetExpr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "TryClause", $count)
};

(:~
 : Parse the 1st loop of production TryCatchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CatchClause($input, $state)
    let $state := p:lookahead1W(163, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'ascending' | 'case' | 'catch' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 86) then                         (: 'catch' :)
        $state
      else
        p:parse-TryCatchExpr-1($input, $state)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TryClause($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TryCatchExpr-1($input, $state)
  return p:reduce($state, "TryCatchExpr", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 133) then                           (: 'is' :)
      let $state := p:shift(133, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '<<' :)
      let $state := p:shift(57, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(63, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: '!=' :)
      let $state := p:shift(27, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<' :)
      let $state := p:shift(53, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: '<=' :)
      let $state := p:shift(58, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(62, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 111) then                           (: 'eq' :)
      let $state := p:shift(111, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'ne' :)
      let $state := p:shift(145, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:shift(139, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:shift(136, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:shift(124, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(120, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(207, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AtomicOrUnionType($input, $state)
  let $state := p:lookahead1W(188, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '?' | ']' | 'and' | 'ascending' | 'case' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 39                             (: '*' :)
          or $state[$p:l1] = 64) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:shift(64, $input, $state)         (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(39, $input, $state)         (: '*' :)
          return $state
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(8, $input, $state)             (: '(#' :)
  let $state := p:shift(35, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(209, $input, $state)           (: URIQualifiedName | QName^Token | S | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(207, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1(20, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(0, $input, $state)         (: PragmaContents :)
      let $state := p:shift(2, $input, $state)              (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(5, $input, $state)             (: '#)' :)
  let $state := p:shift(30, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(90, $input, $state)         (: S^WS | '(#' | ('(' ':') | '{' :)
    return
      if ($state[$p:l1] != 35) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(190, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 66) then                       (: '@' :)
      let $state := p:shift(66, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 87) then                            (: 'child' :)
      let $state := p:shift(87, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'descendant' :)
      let $state := p:shift(98, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'attribute' :)
      let $state := p:shift(78, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:shift(173, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'property' :)
      let $state := p:shift(167, $input, $state)            (: 'property' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant-or-self' :)
      let $state := p:shift(99, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'following-sibling' :)
      let $state := p:shift(116, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(115, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'attribute' :)
      let $state := p:lookahead2W(196, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 87                             (: 'descendant' :)
          or $state[$p:l1] = 98                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 99                             (: 'following' :)
          or $state[$p:l1] = 115                            (: 'following-sibling' :)
          or $state[$p:l1] = 116                            (: 'namespace' :)
          or $state[$p:l1] = 143                            (: 'property' :)
          or $state[$p:l1] = 167                            (: 'self' :)
          or $state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:lookahead2W(193, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 12878                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12887                               (: 'child' '::' :)
     or $state[$p:lk] = 12898                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12899                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12915                               (: 'following' '::' :)
     or $state[$p:lk] = 12916                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12943                               (: 'namespace' '::' :)
     or $state[$p:lk] = 12967                               (: 'property' '::' :)
     or $state[$p:lk] = 12973) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(45, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(208, $input, $state)           (: Wildcard | URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: Wildcard :)
      let $state := p:shift(6, $input, $state)              (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(208, $input, $state)           (: Wildcard | URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78                                  (: 'binary' :)
     or $state[$p:l1] = 80                                  (: 'comment' :)
     or $state[$p:l1] = 89                                  (: 'document-node' :)
     or $state[$p:l1] = 104                                 (: 'element' :)
     or $state[$p:l1] = 105                                 (: 'namespace-node' :)
     or $state[$p:l1] = 144                                 (: 'node' :)
     or $state[$p:l1] = 149                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 166                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 171                                 (: 'schema-element' :)
     or $state[$p:l1] = 172                                 (: 'text' :)
     or $state[$p:l1] = 182) then                           (: 'text' :)
      let $state := p:lookahead2W(192, $input, $state)      (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8782                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8784                                (: 'binary' '(' :)
     or $state[$p:lk] = 8793                                (: 'comment' '(' :)
     or $state[$p:lk] = 8808                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8809                                (: 'element' '(' :)
     or $state[$p:lk] = 8848                                (: 'namespace-node' '(' :)
     or $state[$p:lk] = 8853                                (: 'node' '(' :)
     or $state[$p:lk] = 8870                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8875                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8876                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8886) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 157) then                           (: 'parent' :)
      let $state := p:shift(157, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor' :)
      let $state := p:shift(72, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding-sibling' :)
      let $state := p:shift(162, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'preceding' :)
      let $state := p:shift(161, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(73, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(43, $input, $state)       (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(50, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 72                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 73                                  (: 'parent' :)
     or $state[$p:l1] = 157                                 (: 'preceding' :)
     or $state[$p:l1] = 161                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 162) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(193, $input, $state)      (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 45                                  (: '..' :)
     or $state[$p:lk] = 12872                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12873                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12957                               (: 'parent' '::' :)
     or $state[$p:lk] = 12961                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12962) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(47, $input, $state)           (: S^WS | ('(' ':') | ']' :)
  let $state := p:shift(69, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(129, $input, $state)          (: S^WS | ('(' ':') | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse InlineFunction.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InlineFunction($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(87, $input, $state)           (: S^WS | '$' | ('(' ':') | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | ('(' ':') | 'as' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExpr($input, $state)
  return p:reduce($state, "InlineFunction", $count)
};

(:~
 : Parse LiteralFunctionItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LiteralFunctionItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  let $state := p:lookahead1W(37, $input, $state)           (: S^WS | '#' | ('(' ':') :)
  let $state := p:shift(29, $input, $state)                 (: '#' :)
  let $state := p:lookahead1W(33, $input, $state)           (: IntegerLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(9, $input, $state)                  (: IntegerLiteral :)
  return p:reduce($state, "LiteralFunctionItem", $count)
};

(:~
 : Parse FunctionItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'function' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8823) then                          (: 'function' '(' :)
      let $state := p:parse-InlineFunction($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-LiteralFunctionItem($input, $state)
      return $state
  return p:reduce($state, "FunctionItemExpr", $count)
};

(:~
 : Parse PrefixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrefixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "PrefixExpr", $count)
};

(:~
 : Parse Prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-NCName($input, $state)
  return p:reduce($state, "Prefix", $count)
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(169, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-PrefixExpr($input, $state)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Prefix($input, $state)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompNamespaceConstructor", $count)
};

(:~
 : Parse CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompBinaryConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(166, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(169, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(89, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(19, $input, $state)            (: '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExprExtended", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(182, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(78, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(213, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(105, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(213, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 200) then                           (: '{' :)
      let $state := p:shift(200, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(79, $input, $state)       (: S^WS | ('(' ':') | '}' :)
      let $state := p:shift(204, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EQName($input, $state)
      return $state
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(228, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 204) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(103, $input, $state)                (: 'document' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 103) then                           (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'binary' :)
      let $state := p:parse-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(59, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(4, $input, $state)             (: PITarget :)
  let $state := p:shift(19, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(23, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 23) then                       (: S :)
      let $state := p:shift(23, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: DirPIContents :)
      let $state := p:shift(4, $input, $state)              (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(12, $input, $state)            (: '?>' :)
  let $state := p:shift(65, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(1, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(3, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(9, $input, $state)             (: '-->' :)
  let $state := p:shift(43, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse CDataSection.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CDataSection($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(55, $input, $state)                 (: '<![CDATA[' :)
  let $state := p:lookahead1(3, $input, $state)             (: CDataSectionContents :)
  let $state := p:shift(5, $input, $state)                  (: CDataSectionContents :)
  let $state := p:lookahead1(13, $input, $state)            (: ']]>' :)
  let $state := p:shift(70, $input, $state)                 (: ']]>' :)
  return p:reduce($state, "CDataSection", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 55) then                       (: '<![CDATA[' :)
      let $state := p:parse-CDataSection($input, $state)
      return $state
    else if ($state[$p:l1] = 16) then                       (: ElementContentChar :)
      let $state := p:shift(16, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 18) then                            (: AposAttrContentChar :)
      let $state := p:shift(18, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(19, $input, $state)            (: '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 13) then                            (: PredefinedEntityRef :)
      let $state := p:shift(13, $input, $state)             (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: CharRef :)
      let $state := p:shift(20, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 201) then                      (: '{{' :)
      let $state := p:shift(201, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 205) then                      (: '}}' :)
      let $state := p:shift(205, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 17) then                            (: QuotAttrContentChar :)
      let $state := p:shift(17, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(147, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 28) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: EscapeQuot :)
            let $state := p:shift(14, $input, $state)       (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(148, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 33) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 15) then                      (: EscapeApos :)
            let $state := p:shift(15, $input, $state)       (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(25, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 28) then                            (: '"' :)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(28, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(33, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(33, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(36, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 23) then                         (: S :)
        $state
      else
        let $state := p:shift(23, $input, $state)           (: S :)
        let $state := p:lookahead1(211, $input, $state)     (: QName^Token | S | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 23                      (: S :)
               and $state[$p:l1] != 48                      (: '/>' :)
               and $state[$p:l1] != 61) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(21, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(10, $input, $state)  (: '=' :)
            let $state := p:shift(60, $input, $state)       (: '=' :)
            let $state := p:lookahead1(35, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 23) then             (: S :)
                let $state := p:shift(23, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(155, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               '<' | '<!--' | '<![CDATA[' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 56) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(53, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(206, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(26, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: '/>' :)
      let $state := p:shift(48, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(61, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(56, $input, $state)             (: '</' :)
      let $state := p:lookahead1(206, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(22, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 23) then                   (: S :)
          let $state := p:shift(23, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(11, $input, $state)        (: '>' :)
      let $state := p:shift(61, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 53                                  (: '<' :)
     or $state[$p:l1] = 54                                  (: '<!--' :)
     or $state[$p:l1] = 59) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(191, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(155, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse ArgumentPlaceholder.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentPlaceholder($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(64, $input, $state)                 (: '?' :)
  return p:reduce($state, "ArgumentPlaceholder", $count)
};

(:~
 : Parse Argument.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Argument($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(226, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:parse-ArgumentPlaceholder($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ExprSingle($input, $state)
      return $state
  return p:reduce($state, "Argument", $count)
};

(:~
 : Parse the 1st loop of production ArgumentList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-Argument($input, $state)
        return p:parse-ArgumentList-1($input, $state)
};

(:~
 : Parse ArgumentList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ArgumentList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(7, $input, $state)             (: '(' :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(230, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '?' | '@' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'binary' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-Argument($input, $state)
      let $state := p:parse-ArgumentList-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ArgumentList", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(198, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'count' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'group' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'namespace' | 'ne' | 'only' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'property' | 'return' |
                                                               'satisfies' | 'self' | 'some' | 'stable' | 'start' |
                                                               'to' | 'treat' | 'try' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: URIQualifiedName :)
      let $state := p:shift(7, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionQName($input, $state)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ArgumentList($input, $state)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(225, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | ')' |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(221, $input, $state)           (: URIQualifiedName | IntegerLiteral | DecimalLiteral |
                                                               DoubleLiteral | StringLiteral | QName^Token | '$' | '(' |
                                                               '.' | '<' | '<!--' | '<?' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 143) then                           (: 'namespace' :)
      let $state := p:lookahead2W(176, $input, $state)      (: NCName^Token | S^WS | '#' | '(' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | '{' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(173, $input, $state)      (: NCName^Token | S^WS | '#' | ('(' ':') | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' | '{' :)
      return $state
    else if ($state[$p:l1] = 78                             (: 'element' :)
          or $state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:lookahead2W(215, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | '#' | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
      return $state
    else if ($state[$p:l1] = 80                             (: 'comment' :)
          or $state[$p:l1] = 89                             (: 'text' :)
          or $state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:lookahead2W(86, $input, $state)       (: S^WS | '#' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 103                            (: 'ordered' :)
          or $state[$p:l1] = 155                            (: 'unordered' :)
          or $state[$p:l1] = 191) then                      (: 'unordered' :)
      let $state := p:lookahead2W(125, $input, $state)      (: S^WS | '#' | '(' | ('(' ':') | '{' :)
      return $state
    else if ($state[$p:l1] = 7                              (: QName^Token :)
          or $state[$p:l1] = 22                             (: 'ancestor' :)
          or $state[$p:l1] = 72                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 73                             (: 'and' :)
          or $state[$p:l1] = 74                             (: 'ascending' :)
          or $state[$p:l1] = 76                             (: 'case' :)
          or $state[$p:l1] = 83                             (: 'cast' :)
          or $state[$p:l1] = 84                             (: 'castable' :)
          or $state[$p:l1] = 85                             (: 'catch' :)
          or $state[$p:l1] = 86                             (: 'child' :)
          or $state[$p:l1] = 87                             (: 'collation' :)
          or $state[$p:l1] = 88                             (: 'count' :)
          or $state[$p:l1] = 93                             (: 'declare' :)
          or $state[$p:l1] = 96                             (: 'default' :)
          or $state[$p:l1] = 97                             (: 'descendant' :)
          or $state[$p:l1] = 98                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 99                             (: 'descending' :)
          or $state[$p:l1] = 100                            (: 'div' :)
          or $state[$p:l1] = 102                            (: 'else' :)
          or $state[$p:l1] = 106                            (: 'empty' :)
          or $state[$p:l1] = 107                            (: 'end' :)
          or $state[$p:l1] = 110                            (: 'eq' :)
          or $state[$p:l1] = 111                            (: 'every' :)
          or $state[$p:l1] = 112                            (: 'except' :)
          or $state[$p:l1] = 113                            (: 'following' :)
          or $state[$p:l1] = 115                            (: 'following-sibling' :)
          or $state[$p:l1] = 116                            (: 'for' :)
          or $state[$p:l1] = 117                            (: 'ge' :)
          or $state[$p:l1] = 120                            (: 'group' :)
          or $state[$p:l1] = 122                            (: 'gt' :)
          or $state[$p:l1] = 124                            (: 'idiv' :)
          or $state[$p:l1] = 125                            (: 'import' :)
          or $state[$p:l1] = 127                            (: 'instance' :)
          or $state[$p:l1] = 131                            (: 'intersect' :)
          or $state[$p:l1] = 132                            (: 'is' :)
          or $state[$p:l1] = 133                            (: 'le' :)
          or $state[$p:l1] = 136                            (: 'let' :)
          or $state[$p:l1] = 138                            (: 'lt' :)
          or $state[$p:l1] = 139                            (: 'mod' :)
          or $state[$p:l1] = 141                            (: 'module' :)
          or $state[$p:l1] = 142                            (: 'ne' :)
          or $state[$p:l1] = 145                            (: 'only' :)
          or $state[$p:l1] = 151                            (: 'or' :)
          or $state[$p:l1] = 153                            (: 'order' :)
          or $state[$p:l1] = 154                            (: 'parent' :)
          or $state[$p:l1] = 157                            (: 'preceding' :)
          or $state[$p:l1] = 161                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 162                            (: 'property' :)
          or $state[$p:l1] = 167                            (: 'return' :)
          or $state[$p:l1] = 168                            (: 'satisfies' :)
          or $state[$p:l1] = 169                            (: 'self' :)
          or $state[$p:l1] = 173                            (: 'some' :)
          or $state[$p:l1] = 175                            (: 'stable' :)
          or $state[$p:l1] = 176                            (: 'start' :)
          or $state[$p:l1] = 177                            (: 'to' :)
          or $state[$p:l1] = 184                            (: 'treat' :)
          or $state[$p:l1] = 185                            (: 'try' :)
          or $state[$p:l1] = 186                            (: 'union' :)
          or $state[$p:l1] = 190                            (: 'validate' :)
          or $state[$p:l1] = 192                            (: 'where' :)
          or $state[$p:l1] = 196                            (: 'xquery' :)
          or $state[$p:l1] = 198) then                      (: 'xquery' :)
      let $state := p:lookahead2W(85, $input, $state)       (: S^WS | '#' | '(' | ('(' ':') :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12) then                            (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 44) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8711                           (: URIQualifiedName '(' :)
          or $state[$p:lk] = 8726                           (: QName^Token '(' :)
          or $state[$p:lk] = 8776                           (: 'ancestor' '(' :)
          or $state[$p:lk] = 8777                           (: 'ancestor-or-self' '(' :)
          or $state[$p:lk] = 8778                           (: 'and' '(' :)
          or $state[$p:lk] = 8780                           (: 'ascending' '(' :)
          or $state[$p:lk] = 8787                           (: 'case' '(' :)
          or $state[$p:lk] = 8788                           (: 'cast' '(' :)
          or $state[$p:lk] = 8789                           (: 'castable' '(' :)
          or $state[$p:lk] = 8790                           (: 'catch' '(' :)
          or $state[$p:lk] = 8791                           (: 'child' '(' :)
          or $state[$p:lk] = 8792                           (: 'collation' '(' :)
          or $state[$p:lk] = 8797                           (: 'count' '(' :)
          or $state[$p:lk] = 8800                           (: 'declare' '(' :)
          or $state[$p:lk] = 8801                           (: 'default' '(' :)
          or $state[$p:lk] = 8802                           (: 'descendant' '(' :)
          or $state[$p:lk] = 8803                           (: 'descendant-or-self' '(' :)
          or $state[$p:lk] = 8804                           (: 'descending' '(' :)
          or $state[$p:lk] = 8806                           (: 'div' '(' :)
          or $state[$p:lk] = 8807                           (: 'document' '(' :)
          or $state[$p:lk] = 8810                           (: 'else' '(' :)
          or $state[$p:lk] = 8811                           (: 'empty' '(' :)
          or $state[$p:lk] = 8814                           (: 'end' '(' :)
          or $state[$p:lk] = 8815                           (: 'eq' '(' :)
          or $state[$p:lk] = 8816                           (: 'every' '(' :)
          or $state[$p:lk] = 8817                           (: 'except' '(' :)
          or $state[$p:lk] = 8819                           (: 'following' '(' :)
          or $state[$p:lk] = 8820                           (: 'following-sibling' '(' :)
          or $state[$p:lk] = 8821                           (: 'for' '(' :)
          or $state[$p:lk] = 8824                           (: 'ge' '(' :)
          or $state[$p:lk] = 8826                           (: 'group' '(' :)
          or $state[$p:lk] = 8828                           (: 'gt' '(' :)
          or $state[$p:lk] = 8829                           (: 'idiv' '(' :)
          or $state[$p:lk] = 8831                           (: 'import' '(' :)
          or $state[$p:lk] = 8835                           (: 'instance' '(' :)
          or $state[$p:lk] = 8836                           (: 'intersect' '(' :)
          or $state[$p:lk] = 8837                           (: 'is' '(' :)
          or $state[$p:lk] = 8840                           (: 'le' '(' :)
          or $state[$p:lk] = 8842                           (: 'let' '(' :)
          or $state[$p:lk] = 8843                           (: 'lt' '(' :)
          or $state[$p:lk] = 8845                           (: 'mod' '(' :)
          or $state[$p:lk] = 8846                           (: 'module' '(' :)
          or $state[$p:lk] = 8847                           (: 'namespace' '(' :)
          or $state[$p:lk] = 8849                           (: 'ne' '(' :)
          or $state[$p:lk] = 8855                           (: 'only' '(' :)
          or $state[$p:lk] = 8857                           (: 'or' '(' :)
          or $state[$p:lk] = 8858                           (: 'order' '(' :)
          or $state[$p:lk] = 8859                           (: 'ordered' '(' :)
          or $state[$p:lk] = 8861                           (: 'parent' '(' :)
          or $state[$p:lk] = 8865                           (: 'preceding' '(' :)
          or $state[$p:lk] = 8866                           (: 'preceding-sibling' '(' :)
          or $state[$p:lk] = 8871                           (: 'property' '(' :)
          or $state[$p:lk] = 8872                           (: 'return' '(' :)
          or $state[$p:lk] = 8873                           (: 'satisfies' '(' :)
          or $state[$p:lk] = 8877                           (: 'self' '(' :)
          or $state[$p:lk] = 8879                           (: 'some' '(' :)
          or $state[$p:lk] = 8880                           (: 'stable' '(' :)
          or $state[$p:lk] = 8881                           (: 'start' '(' :)
          or $state[$p:lk] = 8888                           (: 'to' '(' :)
          or $state[$p:lk] = 8889                           (: 'treat' '(' :)
          or $state[$p:lk] = 8890                           (: 'try' '(' :)
          or $state[$p:lk] = 8894                           (: 'union' '(' :)
          or $state[$p:lk] = 8895                           (: 'unordered' '(' :)
          or $state[$p:lk] = 8896                           (: 'validate' '(' :)
          or $state[$p:lk] = 8900                           (: 'where' '(' :)
          or $state[$p:lk] = 8902) then                     (: 'xquery' '(' :)
      let $state := p:parse-FunctionCall($input, $state)
      return $state
    else if ($state[$p:lk] = 51355) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51391) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 104                            (: 'document-node' :)
          or $state[$p:lk] = 108                            (: 'empty-sequence' :)
          or $state[$p:lk] = 119                            (: 'function' :)
          or $state[$p:lk] = 126                            (: 'if' :)
          or $state[$p:lk] = 134                            (: 'item' :)
          or $state[$p:lk] = 144                            (: 'namespace-node' :)
          or $state[$p:lk] = 149                            (: 'node' :)
          or $state[$p:lk] = 171                            (: 'schema-attribute' :)
          or $state[$p:lk] = 172                            (: 'schema-element' :)
          or $state[$p:lk] = 181                            (: 'switch' :)
          or $state[$p:lk] = 189                            (: 'typeswitch' :)
          or $state[$p:lk] = 7431                           (: URIQualifiedName '#' :)
          or $state[$p:lk] = 7446                           (: QName^Token '#' :)
          or $state[$p:lk] = 7496                           (: 'ancestor' '#' :)
          or $state[$p:lk] = 7497                           (: 'ancestor-or-self' '#' :)
          or $state[$p:lk] = 7498                           (: 'and' '#' :)
          or $state[$p:lk] = 7500                           (: 'ascending' '#' :)
          or $state[$p:lk] = 7502                           (: 'attribute' '#' :)
          or $state[$p:lk] = 7504                           (: 'binary' '#' :)
          or $state[$p:lk] = 7507                           (: 'case' '#' :)
          or $state[$p:lk] = 7508                           (: 'cast' '#' :)
          or $state[$p:lk] = 7509                           (: 'castable' '#' :)
          or $state[$p:lk] = 7510                           (: 'catch' '#' :)
          or $state[$p:lk] = 7511                           (: 'child' '#' :)
          or $state[$p:lk] = 7512                           (: 'collation' '#' :)
          or $state[$p:lk] = 7513                           (: 'comment' '#' :)
          or $state[$p:lk] = 7517                           (: 'count' '#' :)
          or $state[$p:lk] = 7520                           (: 'declare' '#' :)
          or $state[$p:lk] = 7521                           (: 'default' '#' :)
          or $state[$p:lk] = 7522                           (: 'descendant' '#' :)
          or $state[$p:lk] = 7523                           (: 'descendant-or-self' '#' :)
          or $state[$p:lk] = 7524                           (: 'descending' '#' :)
          or $state[$p:lk] = 7526                           (: 'div' '#' :)
          or $state[$p:lk] = 7527                           (: 'document' '#' :)
          or $state[$p:lk] = 7529                           (: 'element' '#' :)
          or $state[$p:lk] = 7530                           (: 'else' '#' :)
          or $state[$p:lk] = 7531                           (: 'empty' '#' :)
          or $state[$p:lk] = 7534                           (: 'end' '#' :)
          or $state[$p:lk] = 7535                           (: 'eq' '#' :)
          or $state[$p:lk] = 7536                           (: 'every' '#' :)
          or $state[$p:lk] = 7537                           (: 'except' '#' :)
          or $state[$p:lk] = 7539                           (: 'following' '#' :)
          or $state[$p:lk] = 7540                           (: 'following-sibling' '#' :)
          or $state[$p:lk] = 7541                           (: 'for' '#' :)
          or $state[$p:lk] = 7544                           (: 'ge' '#' :)
          or $state[$p:lk] = 7546                           (: 'group' '#' :)
          or $state[$p:lk] = 7548                           (: 'gt' '#' :)
          or $state[$p:lk] = 7549                           (: 'idiv' '#' :)
          or $state[$p:lk] = 7551                           (: 'import' '#' :)
          or $state[$p:lk] = 7555                           (: 'instance' '#' :)
          or $state[$p:lk] = 7556                           (: 'intersect' '#' :)
          or $state[$p:lk] = 7557                           (: 'is' '#' :)
          or $state[$p:lk] = 7560                           (: 'le' '#' :)
          or $state[$p:lk] = 7562                           (: 'let' '#' :)
          or $state[$p:lk] = 7563                           (: 'lt' '#' :)
          or $state[$p:lk] = 7565                           (: 'mod' '#' :)
          or $state[$p:lk] = 7566                           (: 'module' '#' :)
          or $state[$p:lk] = 7567                           (: 'namespace' '#' :)
          or $state[$p:lk] = 7569                           (: 'ne' '#' :)
          or $state[$p:lk] = 7575                           (: 'only' '#' :)
          or $state[$p:lk] = 7577                           (: 'or' '#' :)
          or $state[$p:lk] = 7578                           (: 'order' '#' :)
          or $state[$p:lk] = 7579                           (: 'ordered' '#' :)
          or $state[$p:lk] = 7581                           (: 'parent' '#' :)
          or $state[$p:lk] = 7585                           (: 'preceding' '#' :)
          or $state[$p:lk] = 7586                           (: 'preceding-sibling' '#' :)
          or $state[$p:lk] = 7590                           (: 'processing-instruction' '#' :)
          or $state[$p:lk] = 7591                           (: 'property' '#' :)
          or $state[$p:lk] = 7592                           (: 'return' '#' :)
          or $state[$p:lk] = 7593                           (: 'satisfies' '#' :)
          or $state[$p:lk] = 7597                           (: 'self' '#' :)
          or $state[$p:lk] = 7599                           (: 'some' '#' :)
          or $state[$p:lk] = 7600                           (: 'stable' '#' :)
          or $state[$p:lk] = 7601                           (: 'start' '#' :)
          or $state[$p:lk] = 7606                           (: 'text' '#' :)
          or $state[$p:lk] = 7608                           (: 'to' '#' :)
          or $state[$p:lk] = 7609                           (: 'treat' '#' :)
          or $state[$p:lk] = 7610                           (: 'try' '#' :)
          or $state[$p:lk] = 7614                           (: 'union' '#' :)
          or $state[$p:lk] = 7615                           (: 'unordered' '#' :)
          or $state[$p:lk] = 7616                           (: 'validate' '#' :)
          or $state[$p:lk] = 7620                           (: 'where' '#' :)
          or $state[$p:lk] = 7622) then                     (: 'xquery' '#' :)
      let $state := p:parse-FunctionItemExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-Constructor($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse the 1st loop of production PostfixExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(192, $input, $state)        (: EOF | S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '(' :)
      and $state[$p:l1] != 68) then                         (: '[' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 68) then                      (: '[' :)
            let $state := p:parse-Predicate($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-ArgumentList($input, $state)
            return $state
        return p:parse-PostfixExpr-1($input, $state)
};

(:~
 : Parse PostfixExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PostfixExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:parse-PostfixExpr-1($input, $state)
  return p:reduce($state, "PostfixExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(222, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | ('(' ':') | '.' | '..' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'attribute' :)
      let $state := p:lookahead2W(233, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21326) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22606) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(83, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24910) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27470) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(135, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30030) then                (: 'attribute' 'for' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33614) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38734) then                (: 'attribute' 'only' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45134) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19534                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 25678) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(161, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23886                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 35406) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28238                      (: 'attribute' 'start' :)
              or $state[$p:lk] = 45390) then                (: 'attribute' 'start' :)
          let $state := p:lookahead3W(149, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31310                      (: 'attribute' 'order' :)
              or $state[$p:lk] = 39502) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21582                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 21838                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 47438) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19022                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 26190                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 27214                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 28494                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 29006                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 30798                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 31822                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 32078                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 33870                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 34126                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 34894                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 35662                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 36174                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 37198                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 39246                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 43086                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 43342                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 47182                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 48718                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 50254) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:lookahead2W(232, $input, $state)      (: EOF | URIQualifiedName | QName^Token | S^WS | '!' |
                                                               '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21353) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22633) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(83, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24937) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27497) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(135, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30057) then                (: 'element' 'for' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33641) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38761) then                (: 'element' 'only' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45161) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19561                      (: 'element' 'descending' :)
              or $state[$p:lk] = 25705) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(161, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23913                      (: 'element' 'let' :)
              or $state[$p:lk] = 35433) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28265                      (: 'element' 'start' :)
              or $state[$p:lk] = 45417) then                (: 'element' 'start' :)
          let $state := p:lookahead3W(149, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31337                      (: 'element' 'order' :)
              or $state[$p:lk] = 39529) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21609                      (: 'element' 'castable' :)
              or $state[$p:lk] = 21865                      (: 'element' 'treat' :)
              or $state[$p:lk] = 47465) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19049                      (: 'element' 'div' :)
              or $state[$p:lk] = 26217                      (: 'element' 'else' :)
              or $state[$p:lk] = 27241                      (: 'element' 'eq' :)
              or $state[$p:lk] = 28521                      (: 'element' 'except' :)
              or $state[$p:lk] = 29033                      (: 'element' 'ge' :)
              or $state[$p:lk] = 30825                      (: 'element' 'gt' :)
              or $state[$p:lk] = 31849                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 32105                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 33897                      (: 'element' 'is' :)
              or $state[$p:lk] = 34153                      (: 'element' 'le' :)
              or $state[$p:lk] = 34921                      (: 'element' 'lt' :)
              or $state[$p:lk] = 35689                      (: 'element' 'mod' :)
              or $state[$p:lk] = 36201                      (: 'element' 'ne' :)
              or $state[$p:lk] = 37225                      (: 'element' 'or' :)
              or $state[$p:lk] = 39273                      (: 'element' 'return' :)
              or $state[$p:lk] = 43113                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 43369                      (: 'element' 'to' :)
              or $state[$p:lk] = 47209                      (: 'element' 'union' :)
              or $state[$p:lk] = 48745                      (: 'element' 'where' :)
              or $state[$p:lk] = 50281) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:lookahead2W(204, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               '::' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'try' | 'union' | 'where' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21391) then                     (: 'namespace' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22671) then                (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(83, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24975) then                (: 'namespace' 'default' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27535) then                (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(135, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30095) then                (: 'namespace' 'for' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33679) then                (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38799) then                (: 'namespace' 'only' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45199) then                (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19599                      (: 'namespace' 'descending' :)
              or $state[$p:lk] = 25743) then                (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(161, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23951                      (: 'namespace' 'let' :)
              or $state[$p:lk] = 35471) then                (: 'namespace' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28303                      (: 'namespace' 'start' :)
              or $state[$p:lk] = 45455) then                (: 'namespace' 'start' :)
          let $state := p:lookahead3W(149, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31375                      (: 'namespace' 'order' :)
              or $state[$p:lk] = 39567) then                (: 'namespace' 'order' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21647                      (: 'namespace' 'castable' :)
              or $state[$p:lk] = 21903                      (: 'namespace' 'treat' :)
              or $state[$p:lk] = 47503) then                (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19087                      (: 'namespace' 'div' :)
              or $state[$p:lk] = 26255                      (: 'namespace' 'else' :)
              or $state[$p:lk] = 27279                      (: 'namespace' 'eq' :)
              or $state[$p:lk] = 28559                      (: 'namespace' 'except' :)
              or $state[$p:lk] = 29071                      (: 'namespace' 'ge' :)
              or $state[$p:lk] = 30863                      (: 'namespace' 'gt' :)
              or $state[$p:lk] = 31887                      (: 'namespace' 'idiv' :)
              or $state[$p:lk] = 32143                      (: 'namespace' 'intersect' :)
              or $state[$p:lk] = 33935                      (: 'namespace' 'is' :)
              or $state[$p:lk] = 34191                      (: 'namespace' 'le' :)
              or $state[$p:lk] = 34959                      (: 'namespace' 'lt' :)
              or $state[$p:lk] = 35727                      (: 'namespace' 'mod' :)
              or $state[$p:lk] = 36239                      (: 'namespace' 'ne' :)
              or $state[$p:lk] = 37263                      (: 'namespace' 'or' :)
              or $state[$p:lk] = 39311                      (: 'namespace' 'return' :)
              or $state[$p:lk] = 43151                      (: 'namespace' 'satisfies' :)
              or $state[$p:lk] = 43407                      (: 'namespace' 'to' :)
              or $state[$p:lk] = 47247                      (: 'namespace' 'union' :)
              or $state[$p:lk] = 48783                      (: 'namespace' 'where' :)
              or $state[$p:lk] = 50319) then                (: 'namespace' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(202, $input, $state)      (: EOF | NCName^Token | S^WS | '!' | '!=' | '#' | '(' |
                                                               ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' | '//' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'try' | 'union' | 'where' | '{' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:lk] = 21414) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(231, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '%' | '(' | '(#' | ('(' ':') |
                                                               '+' | '-' | '.' | '..' | '/' | '//' | '<' | '<!--' |
                                                               '<?' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 22694) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(83, $input, $state)   (: URILiteral | S^WS | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 24998) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(126, $input, $state)  (: S^WS | '$' | ('(' ':') | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 27558) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(135, $input, $state)  (: S^WS | ('(' ':') | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 30118) then                (: 'processing-instruction' 'for' :)
          let $state := p:lookahead3W(139, $input, $state)  (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' | '{' :)
          return $state
        else if ($state[$p:lk] = 33702) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | ('(' ':') | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 38822) then                (: 'processing-instruction' 'only' :)
          let $state := p:lookahead3W(110, $input, $state)  (: S^WS | ('(' ':') | 'end' | '{' :)
          return $state
        else if ($state[$p:lk] = 45222) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(118, $input, $state)  (: S^WS | ('(' ':') | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 19622                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 25766) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(161, $input, $state)  (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' | '{' :)
          return $state
        else if ($state[$p:lk] = 23974                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 35494) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '$' | ('(' ':') | '{' :)
          return $state
        else if ($state[$p:lk] = 28326                      (: 'processing-instruction' 'start' :)
              or $state[$p:lk] = 45478) then                (: 'processing-instruction' 'start' :)
          let $state := p:lookahead3W(149, $input, $state)  (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' | '{' :)
          return $state
        else if ($state[$p:lk] = 31398                      (: 'processing-instruction' 'order' :)
              or $state[$p:lk] = 39590) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(103, $input, $state)  (: S^WS | ('(' ':') | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 21670                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 21926                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 47526) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(101, $input, $state)  (: S^WS | ('(' ':') | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 19110                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 26278                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 27302                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 28582                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 29094                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 30886                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 31910                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 32166                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 33958                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 34214                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 34982                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 35750                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 36262                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 37286                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 39334                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 43174                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 43430                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 47270                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 48806                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 50342) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(227, $input, $state)  (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 108                            (: 'if' :)
          or $state[$p:l1] = 126                            (: 'item' :)
          or $state[$p:l1] = 134                            (: 'switch' :)
          or $state[$p:l1] = 181                            (: 'typeswitch' :)
          or $state[$p:l1] = 189) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(191, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | ('(' ':') | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 80                             (: 'comment' :)
          or $state[$p:l1] = 89                             (: 'document' :)
          or $state[$p:l1] = 103                            (: 'ordered' :)
          or $state[$p:l1] = 155                            (: 'text' :)
          or $state[$p:l1] = 182                            (: 'unordered' :)
          or $state[$p:l1] = 191) then                      (: 'unordered' :)
      let $state := p:lookahead2W(201, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 72                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 73                             (: 'child' :)
          or $state[$p:l1] = 87                             (: 'descendant' :)
          or $state[$p:l1] = 98                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 99                             (: 'following' :)
          or $state[$p:l1] = 115                            (: 'following-sibling' :)
          or $state[$p:l1] = 116                            (: 'parent' :)
          or $state[$p:l1] = 157                            (: 'preceding' :)
          or $state[$p:l1] = 161                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 162                            (: 'property' :)
          or $state[$p:l1] = 167                            (: 'self' :)
          or $state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:lookahead2W(200, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 7                              (: QName^Token :)
          or $state[$p:l1] = 22                             (: 'and' :)
          or $state[$p:l1] = 74                             (: 'ascending' :)
          or $state[$p:l1] = 76                             (: 'case' :)
          or $state[$p:l1] = 83                             (: 'cast' :)
          or $state[$p:l1] = 84                             (: 'castable' :)
          or $state[$p:l1] = 85                             (: 'catch' :)
          or $state[$p:l1] = 86                             (: 'collation' :)
          or $state[$p:l1] = 88                             (: 'count' :)
          or $state[$p:l1] = 93                             (: 'declare' :)
          or $state[$p:l1] = 96                             (: 'default' :)
          or $state[$p:l1] = 97                             (: 'descending' :)
          or $state[$p:l1] = 100                            (: 'div' :)
          or $state[$p:l1] = 102                            (: 'document-node' :)
          or $state[$p:l1] = 104                            (: 'else' :)
          or $state[$p:l1] = 106                            (: 'empty' :)
          or $state[$p:l1] = 107                            (: 'end' :)
          or $state[$p:l1] = 110                            (: 'eq' :)
          or $state[$p:l1] = 111                            (: 'every' :)
          or $state[$p:l1] = 112                            (: 'except' :)
          or $state[$p:l1] = 113                            (: 'for' :)
          or $state[$p:l1] = 117                            (: 'function' :)
          or $state[$p:l1] = 119                            (: 'ge' :)
          or $state[$p:l1] = 120                            (: 'group' :)
          or $state[$p:l1] = 122                            (: 'gt' :)
          or $state[$p:l1] = 124                            (: 'idiv' :)
          or $state[$p:l1] = 125                            (: 'import' :)
          or $state[$p:l1] = 127                            (: 'instance' :)
          or $state[$p:l1] = 131                            (: 'intersect' :)
          or $state[$p:l1] = 132                            (: 'is' :)
          or $state[$p:l1] = 133                            (: 'le' :)
          or $state[$p:l1] = 136                            (: 'let' :)
          or $state[$p:l1] = 138                            (: 'lt' :)
          or $state[$p:l1] = 139                            (: 'mod' :)
          or $state[$p:l1] = 141                            (: 'module' :)
          or $state[$p:l1] = 142                            (: 'namespace-node' :)
          or $state[$p:l1] = 144                            (: 'ne' :)
          or $state[$p:l1] = 145                            (: 'node' :)
          or $state[$p:l1] = 149                            (: 'only' :)
          or $state[$p:l1] = 151                            (: 'or' :)
          or $state[$p:l1] = 153                            (: 'order' :)
          or $state[$p:l1] = 154                            (: 'return' :)
          or $state[$p:l1] = 168                            (: 'satisfies' :)
          or $state[$p:l1] = 169                            (: 'schema-attribute' :)
          or $state[$p:l1] = 171                            (: 'schema-element' :)
          or $state[$p:l1] = 172                            (: 'some' :)
          or $state[$p:l1] = 175                            (: 'stable' :)
          or $state[$p:l1] = 176                            (: 'start' :)
          or $state[$p:l1] = 177                            (: 'to' :)
          or $state[$p:l1] = 184                            (: 'treat' :)
          or $state[$p:l1] = 185                            (: 'try' :)
          or $state[$p:l1] = 186                            (: 'union' :)
          or $state[$p:l1] = 190                            (: 'validate' :)
          or $state[$p:l1] = 192                            (: 'where' :)
          or $state[$p:l1] = 196                            (: 'xquery' :)
          or $state[$p:l1] = 198) then                      (: 'xquery' :)
      let $state := p:lookahead2W(195, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 9                                   (: IntegerLiteral :)
     or $state[$p:lk] = 10                                  (: DecimalLiteral :)
     or $state[$p:lk] = 11                                  (: DoubleLiteral :)
     or $state[$p:lk] = 12                                  (: StringLiteral :)
     or $state[$p:lk] = 31                                  (: '$' :)
     or $state[$p:lk] = 34                                  (: '(' :)
     or $state[$p:lk] = 44                                  (: '.' :)
     or $state[$p:lk] = 53                                  (: '<' :)
     or $state[$p:lk] = 54                                  (: '<!--' :)
     or $state[$p:lk] = 59                                  (: '<?' :)
     or $state[$p:lk] = 1870                                (: 'attribute' URIQualifiedName :)
     or $state[$p:lk] = 1897                                (: 'element' URIQualifiedName :)
     or $state[$p:lk] = 5519                                (: 'namespace' NCName^Token :)
     or $state[$p:lk] = 5542                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 5710                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 5737                                (: 'element' QName^Token :)
     or $state[$p:lk] = 7431                                (: URIQualifiedName '#' :)
     or $state[$p:lk] = 7446                                (: QName^Token '#' :)
     or $state[$p:lk] = 7496                                (: 'ancestor' '#' :)
     or $state[$p:lk] = 7497                                (: 'ancestor-or-self' '#' :)
     or $state[$p:lk] = 7498                                (: 'and' '#' :)
     or $state[$p:lk] = 7500                                (: 'ascending' '#' :)
     or $state[$p:lk] = 7502                                (: 'attribute' '#' :)
     or $state[$p:lk] = 7504                                (: 'binary' '#' :)
     or $state[$p:lk] = 7507                                (: 'case' '#' :)
     or $state[$p:lk] = 7508                                (: 'cast' '#' :)
     or $state[$p:lk] = 7509                                (: 'castable' '#' :)
     or $state[$p:lk] = 7510                                (: 'catch' '#' :)
     or $state[$p:lk] = 7511                                (: 'child' '#' :)
     or $state[$p:lk] = 7512                                (: 'collation' '#' :)
     or $state[$p:lk] = 7513                                (: 'comment' '#' :)
     or $state[$p:lk] = 7517                                (: 'count' '#' :)
     or $state[$p:lk] = 7520                                (: 'declare' '#' :)
     or $state[$p:lk] = 7521                                (: 'default' '#' :)
     or $state[$p:lk] = 7522                                (: 'descendant' '#' :)
     or $state[$p:lk] = 7523                                (: 'descendant-or-self' '#' :)
     or $state[$p:lk] = 7524                                (: 'descending' '#' :)
     or $state[$p:lk] = 7526                                (: 'div' '#' :)
     or $state[$p:lk] = 7527                                (: 'document' '#' :)
     or $state[$p:lk] = 7528                                (: 'document-node' '#' :)
     or $state[$p:lk] = 7529                                (: 'element' '#' :)
     or $state[$p:lk] = 7530                                (: 'else' '#' :)
     or $state[$p:lk] = 7531                                (: 'empty' '#' :)
     or $state[$p:lk] = 7532                                (: 'empty-sequence' '#' :)
     or $state[$p:lk] = 7534                                (: 'end' '#' :)
     or $state[$p:lk] = 7535                                (: 'eq' '#' :)
     or $state[$p:lk] = 7536                                (: 'every' '#' :)
     or $state[$p:lk] = 7537                                (: 'except' '#' :)
     or $state[$p:lk] = 7539                                (: 'following' '#' :)
     or $state[$p:lk] = 7540                                (: 'following-sibling' '#' :)
     or $state[$p:lk] = 7541                                (: 'for' '#' :)
     or $state[$p:lk] = 7543                                (: 'function' '#' :)
     or $state[$p:lk] = 7544                                (: 'ge' '#' :)
     or $state[$p:lk] = 7546                                (: 'group' '#' :)
     or $state[$p:lk] = 7548                                (: 'gt' '#' :)
     or $state[$p:lk] = 7549                                (: 'idiv' '#' :)
     or $state[$p:lk] = 7550                                (: 'if' '#' :)
     or $state[$p:lk] = 7551                                (: 'import' '#' :)
     or $state[$p:lk] = 7555                                (: 'instance' '#' :)
     or $state[$p:lk] = 7556                                (: 'intersect' '#' :)
     or $state[$p:lk] = 7557                                (: 'is' '#' :)
     or $state[$p:lk] = 7558                                (: 'item' '#' :)
     or $state[$p:lk] = 7560                                (: 'le' '#' :)
     or $state[$p:lk] = 7562                                (: 'let' '#' :)
     or $state[$p:lk] = 7563                                (: 'lt' '#' :)
     or $state[$p:lk] = 7565                                (: 'mod' '#' :)
     or $state[$p:lk] = 7566                                (: 'module' '#' :)
     or $state[$p:lk] = 7567                                (: 'namespace' '#' :)
     or $state[$p:lk] = 7568                                (: 'namespace-node' '#' :)
     or $state[$p:lk] = 7569                                (: 'ne' '#' :)
     or $state[$p:lk] = 7573                                (: 'node' '#' :)
     or $state[$p:lk] = 7575                                (: 'only' '#' :)
     or $state[$p:lk] = 7577                                (: 'or' '#' :)
     or $state[$p:lk] = 7578                                (: 'order' '#' :)
     or $state[$p:lk] = 7579                                (: 'ordered' '#' :)
     or $state[$p:lk] = 7581                                (: 'parent' '#' :)
     or $state[$p:lk] = 7585                                (: 'preceding' '#' :)
     or $state[$p:lk] = 7586                                (: 'preceding-sibling' '#' :)
     or $state[$p:lk] = 7590                                (: 'processing-instruction' '#' :)
     or $state[$p:lk] = 7591                                (: 'property' '#' :)
     or $state[$p:lk] = 7592                                (: 'return' '#' :)
     or $state[$p:lk] = 7593                                (: 'satisfies' '#' :)
     or $state[$p:lk] = 7595                                (: 'schema-attribute' '#' :)
     or $state[$p:lk] = 7596                                (: 'schema-element' '#' :)
     or $state[$p:lk] = 7597                                (: 'self' '#' :)
     or $state[$p:lk] = 7599                                (: 'some' '#' :)
     or $state[$p:lk] = 7600                                (: 'stable' '#' :)
     or $state[$p:lk] = 7601                                (: 'start' '#' :)
     or $state[$p:lk] = 7605                                (: 'switch' '#' :)
     or $state[$p:lk] = 7606                                (: 'text' '#' :)
     or $state[$p:lk] = 7608                                (: 'to' '#' :)
     or $state[$p:lk] = 7609                                (: 'treat' '#' :)
     or $state[$p:lk] = 7610                                (: 'try' '#' :)
     or $state[$p:lk] = 7613                                (: 'typeswitch' '#' :)
     or $state[$p:lk] = 7614                                (: 'union' '#' :)
     or $state[$p:lk] = 7615                                (: 'unordered' '#' :)
     or $state[$p:lk] = 7616                                (: 'validate' '#' :)
     or $state[$p:lk] = 7620                                (: 'where' '#' :)
     or $state[$p:lk] = 7622                                (: 'xquery' '#' :)
     or $state[$p:lk] = 8711                                (: URIQualifiedName '(' :)
     or $state[$p:lk] = 8726                                (: QName^Token '(' :)
     or $state[$p:lk] = 8776                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 8777                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 8778                                (: 'and' '(' :)
     or $state[$p:lk] = 8780                                (: 'ascending' '(' :)
     or $state[$p:lk] = 8787                                (: 'case' '(' :)
     or $state[$p:lk] = 8788                                (: 'cast' '(' :)
     or $state[$p:lk] = 8789                                (: 'castable' '(' :)
     or $state[$p:lk] = 8790                                (: 'catch' '(' :)
     or $state[$p:lk] = 8791                                (: 'child' '(' :)
     or $state[$p:lk] = 8792                                (: 'collation' '(' :)
     or $state[$p:lk] = 8797                                (: 'count' '(' :)
     or $state[$p:lk] = 8800                                (: 'declare' '(' :)
     or $state[$p:lk] = 8801                                (: 'default' '(' :)
     or $state[$p:lk] = 8802                                (: 'descendant' '(' :)
     or $state[$p:lk] = 8803                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 8804                                (: 'descending' '(' :)
     or $state[$p:lk] = 8806                                (: 'div' '(' :)
     or $state[$p:lk] = 8807                                (: 'document' '(' :)
     or $state[$p:lk] = 8810                                (: 'else' '(' :)
     or $state[$p:lk] = 8811                                (: 'empty' '(' :)
     or $state[$p:lk] = 8814                                (: 'end' '(' :)
     or $state[$p:lk] = 8815                                (: 'eq' '(' :)
     or $state[$p:lk] = 8816                                (: 'every' '(' :)
     or $state[$p:lk] = 8817                                (: 'except' '(' :)
     or $state[$p:lk] = 8819                                (: 'following' '(' :)
     or $state[$p:lk] = 8820                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 8821                                (: 'for' '(' :)
     or $state[$p:lk] = 8823                                (: 'function' '(' :)
     or $state[$p:lk] = 8824                                (: 'ge' '(' :)
     or $state[$p:lk] = 8826                                (: 'group' '(' :)
     or $state[$p:lk] = 8828                                (: 'gt' '(' :)
     or $state[$p:lk] = 8829                                (: 'idiv' '(' :)
     or $state[$p:lk] = 8831                                (: 'import' '(' :)
     or $state[$p:lk] = 8835                                (: 'instance' '(' :)
     or $state[$p:lk] = 8836                                (: 'intersect' '(' :)
     or $state[$p:lk] = 8837                                (: 'is' '(' :)
     or $state[$p:lk] = 8840                                (: 'le' '(' :)
     or $state[$p:lk] = 8842                                (: 'let' '(' :)
     or $state[$p:lk] = 8843                                (: 'lt' '(' :)
     or $state[$p:lk] = 8845                                (: 'mod' '(' :)
     or $state[$p:lk] = 8846                                (: 'module' '(' :)
     or $state[$p:lk] = 8847                                (: 'namespace' '(' :)
     or $state[$p:lk] = 8849                                (: 'ne' '(' :)
     or $state[$p:lk] = 8855                                (: 'only' '(' :)
     or $state[$p:lk] = 8857                                (: 'or' '(' :)
     or $state[$p:lk] = 8858                                (: 'order' '(' :)
     or $state[$p:lk] = 8859                                (: 'ordered' '(' :)
     or $state[$p:lk] = 8861                                (: 'parent' '(' :)
     or $state[$p:lk] = 8865                                (: 'preceding' '(' :)
     or $state[$p:lk] = 8866                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 8871                                (: 'property' '(' :)
     or $state[$p:lk] = 8872                                (: 'return' '(' :)
     or $state[$p:lk] = 8873                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 8877                                (: 'self' '(' :)
     or $state[$p:lk] = 8879                                (: 'some' '(' :)
     or $state[$p:lk] = 8880                                (: 'stable' '(' :)
     or $state[$p:lk] = 8881                                (: 'start' '(' :)
     or $state[$p:lk] = 8888                                (: 'to' '(' :)
     or $state[$p:lk] = 8889                                (: 'treat' '(' :)
     or $state[$p:lk] = 8890                                (: 'try' '(' :)
     or $state[$p:lk] = 8894                                (: 'union' '(' :)
     or $state[$p:lk] = 8895                                (: 'unordered' '(' :)
     or $state[$p:lk] = 8896                                (: 'validate' '(' :)
     or $state[$p:lk] = 8900                                (: 'where' '(' :)
     or $state[$p:lk] = 8902                                (: 'xquery' '(' :)
     or $state[$p:lk] = 18510                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 18537                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 18766                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 18793                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 20046                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 20073                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 20558                               (: 'attribute' 'binary' :)
     or $state[$p:lk] = 20585                               (: 'element' 'binary' :)
     or $state[$p:lk] = 22094                               (: 'attribute' 'catch' :)
     or $state[$p:lk] = 22121                               (: 'element' 'catch' :)
     or $state[$p:lk] = 22350                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 22377                               (: 'element' 'child' :)
     or $state[$p:lk] = 22862                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 22889                               (: 'element' 'comment' :)
     or $state[$p:lk] = 24654                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 24681                               (: 'element' 'declare' :)
     or $state[$p:lk] = 25166                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 25193                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 25422                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 25449                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 26446                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 26473                               (: 'element' 'document' :)
     or $state[$p:lk] = 26702                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 26729                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 26958                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 26985                               (: 'element' 'element' :)
     or $state[$p:lk] = 27726                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 27753                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 28750                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 28777                               (: 'element' 'every' :)
     or $state[$p:lk] = 29518                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 29545                               (: 'element' 'following' :)
     or $state[$p:lk] = 29774                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 29801                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 30542                               (: 'attribute' 'function' :)
     or $state[$p:lk] = 30569                               (: 'element' 'function' :)
     or $state[$p:lk] = 32334                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 32361                               (: 'element' 'if' :)
     or $state[$p:lk] = 32590                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 32617                               (: 'element' 'import' :)
     or $state[$p:lk] = 34382                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 34409                               (: 'element' 'item' :)
     or $state[$p:lk] = 36430                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 36457                               (: 'element' 'module' :)
     or $state[$p:lk] = 36686                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 36713                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 36942                               (: 'attribute' 'namespace-node' :)
     or $state[$p:lk] = 36969                               (: 'element' 'namespace-node' :)
     or $state[$p:lk] = 38222                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 38249                               (: 'element' 'node' :)
     or $state[$p:lk] = 39758                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 39785                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 40270                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 40297                               (: 'element' 'parent' :)
     or $state[$p:lk] = 41294                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 41321                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 41550                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 41577                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 42574                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 42601                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 42830                               (: 'attribute' 'property' :)
     or $state[$p:lk] = 42857                               (: 'element' 'property' :)
     or $state[$p:lk] = 43854                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 43881                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 44110                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 44137                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 44366                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 44393                               (: 'element' 'self' :)
     or $state[$p:lk] = 44878                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 44905                               (: 'element' 'some' :)
     or $state[$p:lk] = 46414                               (: 'attribute' 'switch' :)
     or $state[$p:lk] = 46441                               (: 'element' 'switch' :)
     or $state[$p:lk] = 46670                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 46697                               (: 'element' 'text' :)
     or $state[$p:lk] = 47694                               (: 'attribute' 'try' :)
     or $state[$p:lk] = 47721                               (: 'element' 'try' :)
     or $state[$p:lk] = 47759                               (: 'namespace' 'try' :)
     or $state[$p:lk] = 47782                               (: 'processing-instruction' 'try' :)
     or $state[$p:lk] = 48462                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 48489                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 48974                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 49001                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 49230                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 49257                               (: 'element' 'validate' :)
     or $state[$p:lk] = 50766                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 50793                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 51278                               (: 'attribute' '{' :)
     or $state[$p:lk] = 51280                               (: 'binary' '{' :)
     or $state[$p:lk] = 51289                               (: 'comment' '{' :)
     or $state[$p:lk] = 51303                               (: 'document' '{' :)
     or $state[$p:lk] = 51305                               (: 'element' '{' :)
     or $state[$p:lk] = 51343                               (: 'namespace' '{' :)
     or $state[$p:lk] = 51355                               (: 'ordered' '{' :)
     or $state[$p:lk] = 51366                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 51382                               (: 'text' '{' :)
     or $state[$p:lk] = 51391                               (: 'unordered' '{' :)
     or $state[$p:lk] = 13126222                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 13126249                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 13126287                            (: 'namespace' 'and' '{' :)
     or $state[$p:lk] = 13126310                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 13126734                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 13126761                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 13126799                            (: 'namespace' 'ascending' '{' :)
     or $state[$p:lk] = 13126822                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 13128526                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 13128553                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 13128591                            (: 'namespace' 'case' '{' :)
     or $state[$p:lk] = 13128614                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 13128782                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 13128809                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 13128847                            (: 'namespace' 'cast' '{' :)
     or $state[$p:lk] = 13128870                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 13129038                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 13129065                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 13129103                            (: 'namespace' 'castable' '{' :)
     or $state[$p:lk] = 13129126                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 13129806                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 13129833                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 13129871                            (: 'namespace' 'collation' '{' :)
     or $state[$p:lk] = 13129894                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 13131086                            (: 'attribute' 'count' '{' :)
     or $state[$p:lk] = 13131113                            (: 'element' 'count' '{' :)
     or $state[$p:lk] = 13131151                            (: 'namespace' 'count' '{' :)
     or $state[$p:lk] = 13131174                            (: 'processing-instruction' 'count' '{' :)
     or $state[$p:lk] = 13132110                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 13132137                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 13132175                            (: 'namespace' 'default' '{' :)
     or $state[$p:lk] = 13132198                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 13132878                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 13132905                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 13132943                            (: 'namespace' 'descending' '{' :)
     or $state[$p:lk] = 13132966                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 13133390                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 13133417                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 13133455                            (: 'namespace' 'div' '{' :)
     or $state[$p:lk] = 13133478                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 13134414                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 13134441                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 13134479                            (: 'namespace' 'else' '{' :)
     or $state[$p:lk] = 13134502                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 13134670                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 13134697                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 13134735                            (: 'namespace' 'empty' '{' :)
     or $state[$p:lk] = 13134758                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 13135438                            (: 'attribute' 'end' '{' :)
     or $state[$p:lk] = 13135465                            (: 'element' 'end' '{' :)
     or $state[$p:lk] = 13135503                            (: 'namespace' 'end' '{' :)
     or $state[$p:lk] = 13135526                            (: 'processing-instruction' 'end' '{' :)
     or $state[$p:lk] = 13135694                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 13135721                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 13135759                            (: 'namespace' 'eq' '{' :)
     or $state[$p:lk] = 13135782                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 13136206                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 13136233                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 13136271                            (: 'namespace' 'except' '{' :)
     or $state[$p:lk] = 13136294                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 13137230                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 13137257                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 13137295                            (: 'namespace' 'for' '{' :)
     or $state[$p:lk] = 13137318                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 13137998                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 13138025                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 13138063                            (: 'namespace' 'ge' '{' :)
     or $state[$p:lk] = 13138086                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 13138510                            (: 'attribute' 'group' '{' :)
     or $state[$p:lk] = 13138537                            (: 'element' 'group' '{' :)
     or $state[$p:lk] = 13138575                            (: 'namespace' 'group' '{' :)
     or $state[$p:lk] = 13138598                            (: 'processing-instruction' 'group' '{' :)
     or $state[$p:lk] = 13139022                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 13139049                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 13139087                            (: 'namespace' 'gt' '{' :)
     or $state[$p:lk] = 13139110                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 13139278                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 13139305                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 13139343                            (: 'namespace' 'idiv' '{' :)
     or $state[$p:lk] = 13139366                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 13140814                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 13140841                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 13140879                            (: 'namespace' 'instance' '{' :)
     or $state[$p:lk] = 13140902                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 13141070                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 13141097                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 13141135                            (: 'namespace' 'intersect' '{' :)
     or $state[$p:lk] = 13141158                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 13141326                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 13141353                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 13141391                            (: 'namespace' 'is' '{' :)
     or $state[$p:lk] = 13141414                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 13142094                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 13142121                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 13142159                            (: 'namespace' 'le' '{' :)
     or $state[$p:lk] = 13142182                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 13142606                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 13142633                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 13142671                            (: 'namespace' 'let' '{' :)
     or $state[$p:lk] = 13142694                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 13142862                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 13142889                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 13142927                            (: 'namespace' 'lt' '{' :)
     or $state[$p:lk] = 13142950                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 13143374                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 13143401                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 13143439                            (: 'namespace' 'mod' '{' :)
     or $state[$p:lk] = 13143462                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 13144398                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 13144425                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 13144463                            (: 'namespace' 'ne' '{' :)
     or $state[$p:lk] = 13144486                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 13145934                            (: 'attribute' 'only' '{' :)
     or $state[$p:lk] = 13145961                            (: 'element' 'only' '{' :)
     or $state[$p:lk] = 13145999                            (: 'namespace' 'only' '{' :)
     or $state[$p:lk] = 13146022                            (: 'processing-instruction' 'only' '{' :)
     or $state[$p:lk] = 13146446                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 13146473                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 13146511                            (: 'namespace' 'or' '{' :)
     or $state[$p:lk] = 13146534                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 13146702                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 13146729                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 13146767                            (: 'namespace' 'order' '{' :)
     or $state[$p:lk] = 13146790                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 13150286                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 13150313                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 13150351                            (: 'namespace' 'return' '{' :)
     or $state[$p:lk] = 13150374                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 13150542                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 13150569                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 13150607                            (: 'namespace' 'satisfies' '{' :)
     or $state[$p:lk] = 13150630                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 13152334                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 13152361                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 13152399                            (: 'namespace' 'stable' '{' :)
     or $state[$p:lk] = 13152422                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 13152590                            (: 'attribute' 'start' '{' :)
     or $state[$p:lk] = 13152617                            (: 'element' 'start' '{' :)
     or $state[$p:lk] = 13152655                            (: 'namespace' 'start' '{' :)
     or $state[$p:lk] = 13152678                            (: 'processing-instruction' 'start' '{' :)
     or $state[$p:lk] = 13154382                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 13154409                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 13154447                            (: 'namespace' 'to' '{' :)
     or $state[$p:lk] = 13154470                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 13154638                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 13154665                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 13154703                            (: 'namespace' 'treat' '{' :)
     or $state[$p:lk] = 13154726                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 13155918                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 13155945                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 13155983                            (: 'namespace' 'union' '{' :)
     or $state[$p:lk] = 13156006                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 13157454                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 13157481                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 13157519                            (: 'namespace' 'where' '{' :)
     or $state[$p:lk] = 13157542) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-PostfixExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(189, $input, $state)        (: EOF | S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 26                               (: '!' :)
      and $state[$p:l1] != 46                               (: '/' :)
      and $state[$p:l1] != 47) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 46) then                      (: '/' :)
            let $state := p:shift(46, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:l1] = 47) then                 (: '//' :)
            let $state := p:shift(47, $input, $state)       (: '//' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(26, $input, $state)       (: '!' :)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 46) then                            (: '/' :)
      let $state := p:shift(46, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(234, $input, $state)      (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '!=' | '$' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '.' | '..' | ';' | '<' | '<!--' |
                                                               '<<' | '<=' | '<?' | '=' | '>' | '>=' | '>>' | '@' |
                                                               ']' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' | '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 1                               (: EOF :)
         or $state[$p:l1] = 27                              (: '!=' :)
         or $state[$p:l1] = 37                              (: ')' :)
         or $state[$p:l1] = 38                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 41                              (: ',' :)
         or $state[$p:l1] = 42                              (: '-' :)
         or $state[$p:l1] = 52                              (: ';' :)
         or $state[$p:l1] = 57                              (: '<<' :)
         or $state[$p:l1] = 58                              (: '<=' :)
         or $state[$p:l1] = 60                              (: '=' :)
         or $state[$p:l1] = 61                              (: '>' :)
         or $state[$p:l1] = 62                              (: '>=' :)
         or $state[$p:l1] = 63                              (: '>>' :)
         or $state[$p:l1] = 69                              (: ']' :)
         or $state[$p:l1] = 202                             (: '|' :)
         or $state[$p:l1] = 203                             (: '||' :)
         or $state[$p:l1] = 204) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 47) then                       (: '//' :)
      let $state := p:shift(47, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 135) then                           (: 'lax' :)
      let $state := p:shift(135, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(178, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(192, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(151, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'full' | 'lax' | 'strict' |
                                                               'type' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 118                           (: 'full' :)
         and $state[$p:l1] != 200) then                     (: '{' :)
      let $state :=
        if ($state[$p:l1] = 135                             (: 'lax' :)
         or $state[$p:l1] = 178) then                       (: 'strict' :)
          let $state := p:parse-ValidationMode($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state :=
            if ($state[$p:l1] = 75) then                    (: 'as' :)
              let $state := p:shift(75, $input, $state)     (: 'as' :)
              return $state
            else if ($state[$p:error]) then
              $state
            else
              let $state := p:shift(188, $input, $state)    (: 'type' :)
              return $state
          let $state := p:lookahead1W(210, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(112, $input, $state)          (: S^WS | ('(' ':') | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 118) then                      (: 'full' :)
      let $state := p:shift(118, $input, $state)            (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(78, $input, $state)           (: S^WS | ('(' ':') | '{' :)
  let $state := p:shift(200, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(79, $input, $state)           (: S^WS | ('(' ':') | '}' :)
  let $state := p:shift(204, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 192) then                           (: 'validate' :)
      let $state := p:lookahead2W(205, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'as' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'full' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'lax' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'strict' |
                                                               'to' | 'treat' | 'type' | 'union' | 'where' | '{' | '|' |
                                                               '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 19392                               (: 'validate' 'as' :)
     or $state[$p:lk] = 30400                               (: 'validate' 'full' :)
     or $state[$p:lk] = 34752                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 45760                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 48320                               (: 'validate' 'type' :)
     or $state[$p:lk] = 51392) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 35) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(223, $input, $state)        (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: '-' :)
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(40, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(187, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:shift(84, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(186, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:shift(85, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(185, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'treat' | 'union' | 'where' | '|' |
                                                               '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 185) then                      (: 'treat' :)
      let $state := p:shift(185, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(183, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'only' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'start' | 'to' | 'union' | 'where' | '|' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:shift(131, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(68, $input, $state)       (: S^WS | ('(' ':') | 'of' :)
      let $state := p:shift(150, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(182, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'except' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                               'let' | 'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'union' | 'where' | '|' | '||' | '}' :)
    return
      if ($state[$p:l1] != 113                              (: 'except' :)
      and $state[$p:l1] != 132) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 132) then                     (: 'intersect' :)
            let $state := p:shift(132, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(113, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(181, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '|' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 190                              (: 'union' :)
      and $state[$p:l1] != 202) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 190) then                     (: 'union' :)
            let $state := p:shift(190, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(202, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(180, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               ']' | 'and' | 'ascending' | 'case' | 'collation' |
                                                               'count' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'end' | 'eq' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'where' | '||' | '}' :)
    return
      if ($state[$p:l1] != 38                               (: '*' :)
      and $state[$p:l1] != 102                              (: 'div' :)
      and $state[$p:l1] != 125                              (: 'idiv' :)
      and $state[$p:l1] != 141) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 38) then                      (: '*' :)
            let $state := p:shift(38, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 102) then                (: 'div' :)
            let $state := p:shift(102, $input, $state)      (: 'div' :)
            return $state
          else if ($state[$p:l1] = 125) then                (: 'idiv' :)
            let $state := p:shift(125, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(141, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(178, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'where' | '||' | '}' :)
    return
      if ($state[$p:l1] != 40                               (: '+' :)
      and $state[$p:l1] != 42) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 40) then                      (: '+' :)
            let $state := p:shift(40, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(42, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(175, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'where' | '||' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 184) then                      (: 'to' :)
      let $state := p:shift(184, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse the 1st loop of production StringConcatExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(171, $input, $state)        (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '||' | '}' :)
    return
      if ($state[$p:l1] != 203) then                        (: '||' :)
        $state
      else
        let $state := p:shift(203, $input, $state)          (: '||' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-RangeExpr($input, $state)
        return p:parse-StringConcatExpr-1($input, $state)
};

(:~
 : Parse StringConcatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StringConcatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:parse-StringConcatExpr-1($input, $state)
  return p:reduce($state, "StringConcatExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StringConcatExpr($input, $state)
  let $state := p:lookahead1W(168, $input, $state)          (: EOF | S^WS | '!=' | ('(' ':') | ')' | ',' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'eq' | 'for' | 'ge' | 'group' | 'gt' | 'is' | 'le' |
                                                               'let' | 'lt' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 27                             (: '!=' :)
          or $state[$p:l1] = 53                             (: '<' :)
          or $state[$p:l1] = 57                             (: '<<' :)
          or $state[$p:l1] = 58                             (: '<=' :)
          or $state[$p:l1] = 60                             (: '=' :)
          or $state[$p:l1] = 61                             (: '>' :)
          or $state[$p:l1] = 62                             (: '>=' :)
          or $state[$p:l1] = 63                             (: '>>' :)
          or $state[$p:l1] = 111                            (: 'eq' :)
          or $state[$p:l1] = 120                            (: 'ge' :)
          or $state[$p:l1] = 124                            (: 'gt' :)
          or $state[$p:l1] = 133                            (: 'is' :)
          or $state[$p:l1] = 136                            (: 'le' :)
          or $state[$p:l1] = 139                            (: 'lt' :)
          or $state[$p:l1] = 145) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 111                             (: 'eq' :)
         or $state[$p:l1] = 120                             (: 'ge' :)
         or $state[$p:l1] = 124                             (: 'gt' :)
         or $state[$p:l1] = 136                             (: 'le' :)
         or $state[$p:l1] = 139                             (: 'lt' :)
         or $state[$p:l1] = 145) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 57                         (: '<<' :)
              or $state[$p:l1] = 63                         (: '>>' :)
              or $state[$p:l1] = 133) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-StringConcatExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(165, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 74) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(74, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(164, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' |
                                                               'ascending' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'else' | 'empty' | 'end' |
                                                               'for' | 'group' | 'let' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 153) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(153, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(126, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(75, $input, $state)           (: S^WS | ('(' ':') | 'then' :)
  let $state := p:shift(183, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | ('(' ':') | 'else' :)
  let $state := p:shift(106, $input, $state)                (: 'else' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse the 1st loop of production SequenceTypeUnion (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(121, $input, $state)        (: S^WS | ('(' ':') | 'return' | '|' :)
    return
      if ($state[$p:l1] != 202) then                        (: '|' :)
        $state
      else
        let $state := p:shift(202, $input, $state)          (: '|' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-SequenceTypeUnion-1($input, $state)
};

(:~
 : Parse SequenceTypeUnion.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceTypeUnion($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:parse-SequenceTypeUnion-1($input, $state)
  return p:reduce($state, "SequenceTypeUnion", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(14, $input, $state)            (: 'case' :)
  let $state := p:shift(83, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(218, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '$' | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(48, $input, $state)       (: S^WS | ('(' ':') | 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceTypeUnion($input, $state)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(104, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(189, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(88, $input, $state)           (: S^WS | '$' | ('(' ':') | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse SwitchCaseOperand.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseOperand($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "SwitchCaseOperand", $count)
};

(:~
 : Parse the 1st loop of production SwitchCaseClause (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(53, $input, $state)         (: S^WS | ('(' ':') | 'case' :)
    let $state := p:shift(83, $input, $state)               (: 'case' :)
    let $state := p:lookahead1W(30, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-SwitchCaseOperand($input, $state)
    let $state := p:lookahead1W(105, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'return' :)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchCaseClause-1($input, $state)
};

(:~
 : Parse SwitchCaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchCaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-SwitchCaseClause-1($input, $state)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "SwitchCaseClause", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(146, $input, $state)        (: EOF | S^WS | ('(' ':') | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse the 1st loop of production SwitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(30, $input, $state)         (: EPSILON | S^WS | ('(' ':') :)
    let $state := p:parse-SwitchCaseClause($input, $state)
    let $state := p:lookahead1W(104, $input, $state)        (: S^WS | ('(' ':') | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 83) then                         (: 'case' :)
        $state
      else
        p:parse-SwitchExpr-1($input, $state)
};

(:~
 : Parse SwitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SwitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(181, $input, $state)                (: 'switch' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SwitchExpr-1($input, $state)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(72, $input, $state)           (: S^WS | ('(' ':') | 'return' :)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "SwitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(94, $input, $state)         (: S^WS | ('(' ':') | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(38, $input, $state)     (: S^WS | '$' | ('(' ':') :)
        let $state := p:shift(31, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(210, $input, $state)    (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(100, $input, $state)    (: S^WS | ('(' ':') | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 75) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(64, $input, $state)     (: S^WS | ('(' ':') | 'in' :)
        let $state := p:shift(128, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 175) then                           (: 'some' :)
      let $state := p:shift(175, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(112, $input, $state)            (: 'every' :)
      return $state
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(169, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse ReturnClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReturnClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(168, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "ReturnClause", $count)
};

(:~
 : Parse CountClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CountClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(93, $input, $state)                 (: 'count' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "CountClause", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(162, $input, $state)          (: S^WS | ('(' ':') | ',' | 'ascending' | 'collation' |
                                                               'count' | 'descending' | 'empty' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 76                             (: 'ascending' :)
          or $state[$p:l1] = 100) then                      (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 76) then                        (: 'ascending' :)
          let $state := p:shift(76, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(100, $input, $state)        (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(159, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' |
                                                               'empty' | 'for' | 'group' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:shift(107, $input, $state)            (: 'empty' :)
      let $state := p:lookahead1W(113, $input, $state)      (: S^WS | ('(' ':') | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 121) then                       (: 'greatest' :)
          let $state := p:shift(121, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(137, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(32, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(156, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 154) then                           (: 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(82, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(176, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(70, $input, $state)       (: S^WS | ('(' ':') | 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(52, $input, $state)       (: S^WS | ('(' ':') | 'by' :)
      let $state := p:shift(82, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse GroupingSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(157, $input, $state)          (: S^WS | ('(' ':') | ',' | 'collation' | 'count' | 'for' |
                                                               'group' | 'let' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(32, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      return $state
    else
      $state
  return p:reduce($state, "GroupingSpec", $count)
};

(:~
 : Parse the 1st loop of production GroupingSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(156, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-GroupingSpec($input, $state)
        return p:parse-GroupingSpecList-1($input, $state)
};

(:~
 : Parse GroupingSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupingSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-GroupingSpec($input, $state)
  let $state := p:parse-GroupingSpecList-1($input, $state)
  return p:reduce($state, "GroupingSpecList", $count)
};

(:~
 : Parse GroupByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GroupByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(122, $input, $state)                (: 'group' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | ('(' ':') | 'by' :)
  let $state := p:shift(82, $input, $state)                 (: 'by' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-GroupingSpecList($input, $state)
  return p:reduce($state, "GroupByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(196, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse IntermediateClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntermediateClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 117                                 (: 'for' :)
     or $state[$p:l1] = 138) then                           (: 'let' :)
      let $state := p:parse-InitialClause($input, $state)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:parse-GroupByClause($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:parse-CountClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrderByClause($input, $state)
      return $state
  return p:reduce($state, "IntermediateClause", $count)
};

(:~
 : Parse SlidingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SlidingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(174, $input, $state)                (: 'sliding' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(197, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowEndCondition($input, $state)
  return p:reduce($state, "SlidingWindowClause", $count)
};

(:~
 : Parse WindowEndCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowEndCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | ('(' ':') | 'end' | 'only' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:shift(151, $input, $state)            (: 'only' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | ('(' ':') | 'end' :)
  let $state := p:shift(110, $input, $state)                (: 'end' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(195, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WindowEndCondition", $count)
};

(:~
 : Parse NextItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NextItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "NextItem", $count)
};

(:~
 : Parse PreviousItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreviousItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "PreviousItem", $count)
};

(:~
 : Parse CurrentItem.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CurrentItem($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "CurrentItem", $count)
};

(:~
 : Parse WindowVars.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowVars($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(143, $input, $state)          (: S^WS | '$' | ('(' ':') | 'at' | 'next' | 'previous' |
                                                               'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 31) then                       (: '$' :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-CurrentItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(142, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(137, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'previous' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 164) then                      (: 'previous' :)
      let $state := p:shift(164, $input, $state)            (: 'previous' :)
      let $state := p:lookahead1W(38, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-PreviousItem($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(115, $input, $state)          (: S^WS | ('(' ':') | 'next' | 'when' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 146) then                      (: 'next' :)
      let $state := p:shift(146, $input, $state)            (: 'next' :)
      let $state := p:lookahead1W(38, $input, $state)       (: S^WS | '$' | ('(' ':') :)
      let $state := p:shift(31, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-NextItem($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "WindowVars", $count)
};

(:~
 : Parse WindowStartCondition.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowStartCondition($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(17, $input, $state)            (: 'start' :)
  let $state := p:shift(177, $input, $state)                (: 'start' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowVars($input, $state)
  let $state := p:lookahead1W(76, $input, $state)           (: S^WS | ('(' ':') | 'when' :)
  let $state := p:shift(195, $input, $state)                (: 'when' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WindowStartCondition", $count)
};

(:~
 : Parse TumblingWindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TumblingWindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(187, $input, $state)                (: 'tumbling' :)
  let $state := p:lookahead1W(77, $input, $state)           (: S^WS | ('(' ':') | 'window' :)
  let $state := p:shift(197, $input, $state)                (: 'window' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | ('(' ':') | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-WindowStartCondition($input, $state)
  let $state := p:lookahead1W(158, $input, $state)          (: S^WS | ('(' ':') | 'count' | 'end' | 'for' | 'group' |
                                                               'let' | 'only' | 'order' | 'return' | 'stable' | 'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 110                            (: 'end' :)
          or $state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:parse-WindowEndCondition($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TumblingWindowClause", $count)
};

(:~
 : Parse WindowClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WindowClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(117, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | ('(' ':') | 'sliding' | 'tumbling' :)
  let $state :=
    if ($state[$p:l1] = 187) then                           (: 'tumbling' :)
      let $state := p:parse-TumblingWindowClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-SlidingWindowClause($input, $state)
      return $state
  return p:reduce($state, "WindowClause", $count)
};

(:~
 : Parse LetBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | ('(' ':') | ':=' :)
  let $state := p:shift(51, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "LetBinding", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(156, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-LetBinding($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(138, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-LetBinding($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(77, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '$' | ('(' ':') :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse AllowingEmpty.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AllowingEmpty($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(71, $input, $state)                 (: 'allowing' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(107, $input, $state)                (: 'empty' :)
  return p:reduce($state, "AllowingEmpty", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(75, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse ForBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '$' :)
  let $state := p:shift(31, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(141, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | ('(' ':') | 'allowing' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 71) then                       (: 'allowing' :)
      let $state := p:parse-AllowingEmpty($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | ('(' ':') | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | ('(' ':') | 'in' :)
  let $state := p:shift(128, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "ForBinding", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(156, $input, $state)        (: S^WS | ('(' ':') | ',' | 'count' | 'for' | 'group' |
                                                               'let' | 'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-ForBinding($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(117, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ForBinding($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse InitialClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InitialClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(27, $input, $state)            (: 'for' | 'let' :)
  let $state :=
    if ($state[$p:l1] = 117) then                           (: 'for' :)
      let $state := p:lookahead2W(127, $input, $state)      (: S^WS | '$' | ('(' ':') | 'sliding' | 'tumbling' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8053) then                          (: 'for' '$' :)
      let $state := p:parse-ForClause($input, $state)
      return $state
    else if ($state[$p:lk] = 138) then                      (: 'let' :)
      let $state := p:parse-LetClause($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-WindowClause($input, $state)
      return $state
  return p:reduce($state, "InitialClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(154, $input, $state)        (: S^WS | ('(' ':') | 'count' | 'for' | 'group' | 'let' |
                                                               'order' | 'return' | 'stable' | 'where' :)
    return
      if ($state[$p:l1] = 168) then                         (: 'return' :)
        $state
      else
        let $state := p:parse-IntermediateClause($input, $state)
        return p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InitialClause($input, $state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state := p:parse-ReturnClause($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(223, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 117) then                           (: 'for' :)
      let $state := p:lookahead2W(203, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'sliding' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'tumbling' | 'union' | 'where' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'try' :)
      let $state := p:lookahead2W(201, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '{' | '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 112                            (: 'let' :)
          or $state[$p:l1] = 138                            (: 'some' :)
          or $state[$p:l1] = 175) then                      (: 'some' :)
      let $state := p:lookahead2W(199, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') |
                                                               ')' | '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else if ($state[$p:l1] = 126                            (: 'switch' :)
          or $state[$p:l1] = 181                            (: 'typeswitch' :)
          or $state[$p:l1] = 189) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(195, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'union' | 'where' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8053                                (: 'for' '$' :)
     or $state[$p:lk] = 8074                                (: 'let' '$' :)
     or $state[$p:lk] = 44661                               (: 'for' 'sliding' :)
     or $state[$p:lk] = 47989) then                         (: 'for' 'tumbling' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8048                           (: 'every' '$' :)
          or $state[$p:lk] = 8111) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8885) then                     (: 'switch' '(' :)
      let $state := p:parse-SwitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8893) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 8830) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 51386) then                    (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse VarValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "VarValue", $count)
};

(:~
 : Parse ParenthesizedItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-ItemType($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedItemType", $count)
};

(:~
 : Parse AtomicOrUnionType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicOrUnionType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "AtomicOrUnionType", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 64) then                            (: '?' :)
      let $state := p:shift(64, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: '*' :)
      let $state := p:shift(39, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(40, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(217, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 108) then                           (: 'empty-sequence' :)
      let $state := p:lookahead2W(197, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8812) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(108, $input, $state)            (: 'empty-sequence' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(194, $input, $state)      (: EOF | S^WS | '!=' | ('(' ':') | ')' | '*' | '*' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      let $state :=
        if ($state[$p:l1] = 39                              (: '*' :)
         or $state[$p:l1] = 40                              (: '+' :)
         or $state[$p:l1] = 64) then                        (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse the 1st loop of production TypedFunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(30, $input, $state)     (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-SequenceType($input, $state)
        return p:parse-TypedFunctionTest-1($input, $state)
};

(:~
 : Parse TypedFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypedFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(219, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'binary' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-SequenceType($input, $state)
      let $state := p:parse-TypedFunctionTest-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | ('(' ':') | 'as' :)
  let $state := p:shift(75, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypedFunctionTest", $count)
};

(:~
 : Parse AnyFunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyFunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(119, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S^WS | ('(' ':') | '*' :)
  let $state := p:shift(38, $input, $state)                 (: '*' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyFunctionTest", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 9) then                             (: IntegerLiteral :)
      let $state := p:shift(9, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: DecimalLiteral :)
      let $state := p:shift(10, $input, $state)             (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(11, $input, $state)             (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(84, $input, $state)            (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral :)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: StringLiteral :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse the 1st loop of production Annotation (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(91, $input, $state)         (: S^WS | ('(' ':') | ')' | ',' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(138, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
        let $state := p:parse-Literal($input, $state)
        return p:parse-Annotation-1($input, $state)
};

(:~
 : Parse Annotation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Annotation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 32) then                            (: '%' :)
      let $state := p:shift(32, $input, $state)             (: '%' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-EQName($input, $state)
      let $state := p:lookahead1W(144, $input, $state)      (: S^WS | '%' | '(' | ('(' ':') | 'function' | 'private' |
                                                               'variable' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 34) then                   (: '(' :)
          let $state := p:shift(34, $input, $state)         (: '(' :)
          let $state := p:lookahead1W(138, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | ('(' ':') :)
          let $state := p:parse-Literal($input, $state)
          let $state := p:parse-Annotation-1($input, $state)
          let $state := p:shift(37, $input, $state)         (: ')' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(165, $input, $state)            (: 'private' :)
      return $state
  return p:reduce($state, "Annotation", $count)
};

(:~
 : Parse the 1st loop of production FunctionTest (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | '%' | ('(' ':') | 'function' | 'private' :)
    return
      if ($state[$p:l1] = 119) then                         (: 'function' :)
        $state
      else
        let $state := p:parse-Annotation($input, $state)
        return p:parse-FunctionTest-1($input, $state)
};

(:~
 : Parse FunctionTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionTest-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'function' :)
      let $state := p:lookahead2W(39, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state :=
        if ($state[$p:lk] = 8823) then                      (: 'function' '(' :)
          let $state := p:lookahead3W(220, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | ')' | '*' | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'binary' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 2499191) then                       (: 'function' '(' '*' :)
      let $state := p:parse-AnyFunctionTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-TypedFunctionTest($input, $state)
      return $state
  return p:reduce($state, "FunctionTest", $count)
};

(:~
 : Parse BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "BinaryTest", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(149, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse NamespaceNodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceNodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(144, $input, $state)                (: 'namespace-node' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "NamespaceNodeTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(182, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(89, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(166, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(172, $input, $state)          (: StringLiteral | NCName^Token | S^WS | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'count' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'end' | 'eq' | 'except' |
                                                               'for' | 'ge' | 'group' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'treat' | 'try' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 12) then                        (: StringLiteral :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(171, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(78, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(216, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(210, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(172, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(210, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-EQName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 38) then                            (: '*' :)
      let $state := p:shift(38, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(105, $input, $state)                (: 'element' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(216, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' |
                                                               '*' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(91, $input, $state)       (: S^WS | ('(' ':') | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 41) then                   (: ',' :)
          let $state := p:shift(41, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(210, $input, $state)  (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(92, $input, $state)   (: S^WS | ('(' ':') | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 64) then               (: '?' :)
              let $state := p:shift(64, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(104, $input, $state)                (: 'document-node' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(34, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(130, $input, $state)          (: S^WS | ('(' ':') | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 37) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 105) then                       (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(37, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 104) then                           (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace-node' :)
      let $state := p:parse-NamespaceNodeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'node' :)
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-BinaryTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(217, $input, $state)          (: URIQualifiedName | QName^Token | S^WS | '%' | '(' |
                                                               ('(' ':') | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'private' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78                                  (: 'binary' :)
     or $state[$p:l1] = 80                                  (: 'comment' :)
     or $state[$p:l1] = 89                                  (: 'document-node' :)
     or $state[$p:l1] = 104                                 (: 'element' :)
     or $state[$p:l1] = 105                                 (: 'function' :)
     or $state[$p:l1] = 119                                 (: 'item' :)
     or $state[$p:l1] = 134                                 (: 'namespace-node' :)
     or $state[$p:l1] = 144                                 (: 'node' :)
     or $state[$p:l1] = 149                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 166                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 171                                 (: 'schema-element' :)
     or $state[$p:l1] = 172                                 (: 'text' :)
     or $state[$p:l1] = 182) then                           (: 'text' :)
      let $state := p:lookahead2W(197, $input, $state)      (: EOF | S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '*' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'allowing' | 'and' |
                                                               'ascending' | 'at' | 'case' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'external' | 'for' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'only' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'start' | 'to' | 'union' | 'where' | '{' |
                                                               '|' | '||' | '}' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 8782                                (: 'attribute' '(' :)
     or $state[$p:lk] = 8784                                (: 'binary' '(' :)
     or $state[$p:lk] = 8793                                (: 'comment' '(' :)
     or $state[$p:lk] = 8808                                (: 'document-node' '(' :)
     or $state[$p:lk] = 8809                                (: 'element' '(' :)
     or $state[$p:lk] = 8848                                (: 'namespace-node' '(' :)
     or $state[$p:lk] = 8853                                (: 'node' '(' :)
     or $state[$p:lk] = 8870                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 8875                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 8876                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 8886) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 8838) then                     (: 'item' '(' :)
      let $state := p:shift(134, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(39, $input, $state)       (: S^WS | '(' | ('(' ':') :)
      let $state := p:shift(34, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(40, $input, $state)       (: S^WS | ('(' ':') | ')' :)
      let $state := p:shift(37, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:lk] = 32                             (: '%' :)
          or $state[$p:lk] = 165                            (: 'private' :)
          or $state[$p:lk] = 8823) then                     (: 'function' '(' :)
      let $state := p:parse-FunctionTest($input, $state)
      return $state
    else if ($state[$p:lk] = 34) then                       (: '(' :)
      let $state := p:parse-ParenthesizedItemType($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicOrUnionType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse ContextItemDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | ('(' ':') | 'context' :)
  let $state := p:shift(91, $input, $state)                 (: 'context' :)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | ('(' ':') | 'item' :)
  let $state := p:shift(134, $input, $state)                (: 'item' :)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | ('(' ':') | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 75) then                       (: 'as' :)
      let $state := p:shift(75, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-ItemType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | ('(' ':') | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 51) then                            (: ':=' :)
      let $state := p:shift(51, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(30, $input, $state)       (: EPSILON | S^WS | ('(' ':') :)
      let $state := p:parse-VarValue($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(114, $input, $state)            (: 'external' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | ('(' ':') | ':=' | ';' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 51) then                   (: ':=' :)
          let $state := p:shift(51, $input, $state)         (: ':=' :)
          let $state := p:lookahead1W(30, $input, $state)   (: EPSILON | S^WS | ('(' ':') :)
          let $state := p:parse-VarDefaultValue($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "ContextItemDecl", $count)
};

(:~
 : Parse ImportStylesheetDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ImportStylesheetDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(74, $input, $state)           (: S^WS | ('(' ':') | 'stylesheet' :)
  let $state := p:shift(180, $input, $state)                (: 'stylesheet' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | ('(' ':') | 'at' :)
  let $state := p:shift(77, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(34, $input, $state)           (: StringLiteral | S^WS | ('(' ':') :)
  let $state := p:shift(12, $input, $state)                 (: StringLiteral :)
  return p:reduce($state, "ImportStylesheetDecl", $count)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(32, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(66, $input, $state)           (: S^WS | ('(' ':') | 'module' :)
  let $state := p:shift(142, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(82, $input, $state)           (: URILiteral | S^WS | ('(' ':') | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(167, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:shift(77, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(32, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ModuleImport", $count)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 143) then                           (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(167, $input, $state)      (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(46, $input, $state)       (: S^WS | ('(' ':') | '=' :)
      let $state := p:shift(60, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(60, $input, $state)       (: S^WS | ('(' ':') | 'element' :)
      let $state := p:shift(105, $input, $state)            (: 'element' :)
      let $state := p:lookahead1W(67, $input, $state)       (: S^WS | ('(' ':') | 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      return $state
  return p:reduce($state, "SchemaPrefix", $count)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(93, $input, $state)         (: S^WS | ('(' ':') | ',' | ';' :)
    return
      if ($state[$p:l1] != 41) then                         (: ',' :)
        $state
      else
        let $state := p:shift(41, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(32, $input, $state)     (: URILiteral | S^WS | ('(' ':') :)
        let $state := p:shift(8, $input, $state)            (: URILiteral :)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(127, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(73, $input, $state)           (: S^WS | ('(' ':') | 'schema' :)
  let $state := p:shift(170, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(124, $input, $state)          (: URILiteral | S^WS | ('(' ':') | 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 8) then                       (: URILiteral :)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(98, $input, $state)           (: S^WS | ('(' ':') | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'at' :)
      let $state := p:shift(77, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(32, $input, $state)       (: URILiteral | S^WS | ('(' ':') :)
      let $state := p:shift(8, $input, $state)              (: URILiteral :)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "SchemaImport", $count)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 127) then                           (: 'import' :)
      let $state := p:lookahead2W(136, $input, $state)      (: S^WS | ('(' ':') | 'module' | 'schema' | 'stylesheet' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 43647) then                         (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:lk] = 36479) then                    (: 'import' 'module' :)
      let $state := p:parse-ModuleImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ImportStylesheetDecl($input, $state)
      return $state
  return p:reduce($state, "Import", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(167, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse DFPropertyName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DFPropertyName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 95) then                            (: 'decimal-separator' :)
      let $state := p:shift(95, $input, $state)             (: 'decimal-separator' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'grouping-separator' :)
      let $state := p:shift(123, $input, $state)            (: 'grouping-separator' :)
      return $state
    else if ($state[$p:l1] = 129) then                      (: 'infinity' :)
      let $state := p:shift(129, $input, $state)            (: 'infinity' :)
      return $state
    else if ($state[$p:l1] = 140) then                      (: 'minus-sign' :)
      let $state := p:shift(140, $input, $state)            (: 'minus-sign' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'NaN' :)
      let $state := p:shift(67, $input, $state)             (: 'NaN' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'percent' :)
      let $state := p:shift(160, $input, $state)            (: 'percent' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'per-mille' :)
      let $state := p:shift(159, $input, $state)            (: 'per-mille' :)
      return $state
    else if ($state[$p:l1] = 199) then                      (: 'zero-digit' :)
      let $state := p:shift(199, $input, $state)            (: 'zero-digit' :)
      return $state
    else if ($state[$p:l1] = 101) then                      (: 'digit' :)
      let $state := p:shift(101, $input, $state)            (: 'digit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(158, $input, $state)            (: 'pattern-separator' :)
      return $state
  return p:reduce($state, "DFPropertyName", $count)
};

(:~
 : Parse FunctionQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 22) then                            (: QName^Token :)
      let $state := p:shift(22, $input, $state)             (: QName^Token :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'ancestor' :)
      let $state := p:shift(72, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(73, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'and' :)
      let $state := p:shift(74, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'ascending' :)
      let $state := p:shift(76, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'case' :)
      let $state := p:shift(83, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:shift(84, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:shift(85, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'catch' :)
      let $state := p:shift(86, $input, $state)             (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'child' :)
      let $state := p:shift(87, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:shift(93, $input, $state)             (: 'count' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'declare' :)
      let $state := p:shift(96, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'descendant' :)
      let $state := p:shift(98, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'descendant-or-self' :)
      let $state := p:shift(99, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descending' :)
      let $state := p:shift(100, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'div' :)
      let $state := p:shift(102, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'document' :)
      let $state := p:shift(103, $input, $state)            (: 'document' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'else' :)
      let $state := p:shift(106, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:shift(107, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'end' :)
      let $state := p:shift(110, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:shift(111, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'every' :)
      let $state := p:shift(112, $input, $state)            (: 'every' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'except' :)
      let $state := p:shift(113, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'following' :)
      let $state := p:shift(115, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'following-sibling' :)
      let $state := p:shift(116, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'for' :)
      let $state := p:shift(117, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'ge' :)
      let $state := p:shift(120, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:shift(122, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:shift(124, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'idiv' :)
      let $state := p:shift(125, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'import' :)
      let $state := p:shift(127, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:shift(131, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'intersect' :)
      let $state := p:shift(132, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:shift(133, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:shift(136, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:shift(138, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:shift(139, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'mod' :)
      let $state := p:shift(141, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'module' :)
      let $state := p:shift(142, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'namespace' :)
      let $state := p:shift(143, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'ne' :)
      let $state := p:shift(145, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:shift(151, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'or' :)
      let $state := p:shift(153, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'ordered' :)
      let $state := p:shift(155, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'parent' :)
      let $state := p:shift(157, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'preceding' :)
      let $state := p:shift(161, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'preceding-sibling' :)
      let $state := p:shift(162, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'property' :)
      let $state := p:shift(167, $input, $state)            (: 'property' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'return' :)
      let $state := p:shift(168, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'satisfies' :)
      let $state := p:shift(169, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 173) then                      (: 'self' :)
      let $state := p:shift(173, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 175) then                      (: 'some' :)
      let $state := p:shift(175, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'stable' :)
      let $state := p:shift(176, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'start' :)
      let $state := p:shift(177, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'to' :)
      let $state := p:shift(184, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'treat' :)
      let $state := p:shift(185, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'try' :)
      let $state := p:shift(186, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'union' :)
      let $state := p:shift(190, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 191) then                      (: 'unordered' :)
      let $state := p:shift(191, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 192) then                      (: 'validate' :)
      let $state := p:shift(192, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 196) then                      (: 'where' :)
      let $state := p:shift(196, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(198, $input, $state)            (: 'xquery' :)
      return $state
  return p:reduce($state, "FunctionQName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(206, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 78) then                            (: 'attribute' :)
      let $state := p:shift(78, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'binary' :)
      let $state := p:shift(80, $input, $state)             (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'comment' :)
      let $state := p:shift(89, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'document-node' :)
      let $state := p:shift(104, $input, $state)            (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 105) then                      (: 'element' :)
      let $state := p:shift(105, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:l1] = 108) then                      (: 'empty-sequence' :)
      let $state := p:shift(108, $input, $state)            (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 119) then                      (: 'function' :)
      let $state := p:shift(119, $input, $state)            (: 'function' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'if' :)
      let $state := p:shift(126, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'item' :)
      let $state := p:shift(134, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'namespace-node' :)
      let $state := p:shift(144, $input, $state)            (: 'namespace-node' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'node' :)
      let $state := p:shift(149, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'processing-instruction' :)
      let $state := p:shift(166, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 171) then                      (: 'schema-attribute' :)
      let $state := p:shift(171, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: 'schema-element' :)
      let $state := p:shift(172, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 181) then                      (: 'switch' :)
      let $state := p:shift(181, $input, $state)            (: 'switch' :)
      return $state
    else if ($state[$p:l1] = 182) then                      (: 'text' :)
      let $state := p:shift(182, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 189) then                      (: 'typeswitch' :)
      let $state := p:shift(189, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionQName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse EQName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EQName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(207, $input, $state)           (: URIQualifiedName | QName^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'count' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'end' |
                                                               'eq' | 'every' | 'except' | 'following' |
                                                               'following-sibling' | 'for' | 'function' | 'ge' |
                                                               'group' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'namespace' | 'namespace-node' |
                                                               'ne' | 'node' | 'only' | 'or' | 'order' | 'ordered' |
                                                               'parent' | 'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'property' | 'return' |
                                                               'satisfies' | 'schema-attribute' | 'schema-element' |
                                                               'self' | 'some' | 'stable' | 'start' | 'switch' |
                                                               'text' | 'to' | 'treat' | 'try' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: URIQualifiedName :)
      let $state := p:shift(7, $input, $state)              (: URIQualifiedName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "EQName", $count)
};

(:~
 : Parse the 1st loop of production DecimalFormatDecl (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(160, $input, $state)        (: S^WS | ('(' ':') | ';' | 'NaN' | 'decimal-separator' |
                                                               'digit' | 'grouping-separator' | 'infinity' |
                                                               'minus-sign' | 'pattern-separator' | 'per-mille' |
                                                               'percent' | 'zero-digit' :)
    return
      if ($state[$p:l1] = 52) then                          (: ';' :)
        $state
      else
        let $state := p:parse-DFPropertyName($input, $state)
        let $state := p:lookahead1W(46, $input, $state)     (: S^WS | ('(' ':') | '=' :)
        let $state := p:shift(60, $input, $state)           (: '=' :)
        let $state := p:lookahead1W(34, $input, $state)     (: StringLiteral | S^WS | ('(' ':') :)
        let $state := p:shift(12, $input, $state)           (: StringLiteral :)
        return p:parse-DecimalFormatDecl-1($input, $state)
};

(:~
 : Parse DecimalFormatDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DecimalFormatDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | ('(' ':') | 'decimal-format' | 'default' :)
  let $state :=
    if ($state[$p:l1] = 94) then                            (: 'decimal-format' :)
      let $state := p:shift(94, $input, $state)             (: 'decimal-format' :)
      let $state := p:lookahead1W(210, $input, $state)      (: URIQualifiedName | QName^Token | S^WS | ('(' ':') |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'count' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'end' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'function' | 'ge' | 'group' | 'gt' | 'idiv' | 'if' |
                                                               'import' | 'instance' | 'intersect' | 'is' | 'item' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'module' | 'namespace' |
                                                               'namespace-node' | 'ne' | 'node' | 'only' | 'or' |
                                                               'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
      let $state := p:parse-EQName($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(58, $input, $state)       (: S^WS | ('(' ':') | 'decimal-format' :)
      let $state := p:shift(94, $input, $state)             (: 'decimal-format' :)
      return $state
  let $state := p:parse-DecimalFormatDecl-1($input, $state)
  return p:reduce($state, "DecimalFormatDecl", $count)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(28, $input, $state)            (: 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:l1] = 130) then                           (: 'inherit' :)
      let $state := p:shift(130, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(147, $input, $state)            (: 'no-inherit' :)
      return $state
  return p:reduce($state, "InheritMode", $count)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(29, $input, $state)            (: 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:l1] = 163) then                           (: 'preserve' :)
      let $state := p:shift(163, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(148, $input, $state)            (: 'no-preserve' :)
      return $state
  return p:reduce($state, "PreserveMode", $count)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | ('(' ':') | 'copy-namespaces' :)
  let $state := p:shift(92, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(116, $input, $state)          (: S^WS | ('(' ':') | 'no-preserve' | 'preserve' :)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | ('(' ':') | ',' :)
  let $state := p:shift(41, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | ('(' ':') | 'inherit' | 'no-inherit' :)
  let $state := p:parse-InheritMode($input, $state)
  return p:reduce($state, "CopyNamespacesDecl", $count)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | ('(' ':') | 'order' :)
  let $state := p:shift(154, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | ('(' ':') | 'empty' :)
  let $state := p:shift(107, $input, $state)                (: 'empty' :)
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | ('(' ':') | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:l1] = 121) then                           (: 'greatest' :)
      let $state := p:shift(121, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(137, $input, $state)            (: 'least' :)
      return $state
  return p:reduce($state, "EmptyOrderDecl", $count)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | ('(' ':') | 'ordering' :)
  let $state := p:shift(156, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(119, $input, $state)          (: S^WS | ('(' ':') | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 155) then                           (: 'ordered' :)
      let $state := p:shift(155, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(191, $input, $state)            (: 'unordered' :)
      return $state
  return p:reduce($state, "OrderingModeDecl", $count)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | ('(' ':') | 'construction' :)
  let $state := p:shift(90, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 179) then                           (: 'strip' :)
      let $state := p:shift(179, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(163, $input, $state)            (: 'preserve' :)
      return $state
  return p:reduce($state, "ConstructionDecl", $count)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | ('(' ':') | 'base-uri' :)
  let $state := p:shift(79, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "BaseURIDecl", $count)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(54, $input, $state)           (: S^WS | ('(' ':') | 'collation' :)
  let $state := p:shift(88, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "DefaultCollationDecl", $count)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | ('(' ':') | 'boundary-space' :)
  let $state := p:shift(81, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(120, $input, $state)          (: S^WS | ('(' ':') | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 163) then                           (: 'preserve' :)
      let $state := p:shift(163, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(179, $input, $state)            (: 'strip' :)
      return $state
  return p:reduce($state, "BoundarySpaceDecl", $count)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 96) then                            (: 'declare' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'decimal-format' |
                                                               'default' | 'ordering' :)
      let $state :=
        if ($state[$p:lk] = 24928) then                     (: 'declare' 'default' :)
          let $state := p:lookahead3W(134, $input, $state)  (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                               'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 20832) then                         (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5792096) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 20320) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23136) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 40032) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 10117472) then                 (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 23648) then                    (: 'declare' 'copy-namespaces' :)
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DecimalFormatDecl($input, $state)
      return $state
  return p:reduce($state, "Setter", $count)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(96, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | ('(' ':') | 'default' :)
  let $state := p:shift(97, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | ('(' ':') | 'element' | 'function' :)
  let $state :=
    if ($state[$p:l1] = 105) then                           (: 'element' :)
      let $state := p:shift(105, $input, $state)            (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(119, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  return p:reduce($state, "DefaultNamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(224, $input, $state)        (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 96) then                          (: 'declare' :)
        let $state := p:lookahead2W(184, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' |
                                                               'base-uri' | 'boundary-space' | 'cast' | 'castable' |
                                                               'construction' | 'context' | 'copy-namespaces' |
                                                               'decimal-format' | 'default' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'option' | 'or' | 'ordering' | 'private' | 'to' |
                                                               'treat' | 'union' | 'variable' | '|' | '||' :)
        return $state
      else if ($state[$p:l1] = 127) then                    (: 'import' :)
        let $state := p:lookahead2W(177, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'or' | 'schema' |
                                                               'stylesheet' | 'to' | 'treat' | 'union' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 20320                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 20832                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 23136                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 23648                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 24160                            (: 'declare' 'decimal-format' :)
      and $state[$p:lk] != 24928                            (: 'declare' 'default' :)
      and $state[$p:lk] != 36479                            (: 'import' 'module' :)
      and $state[$p:lk] != 36704                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 40032                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 43647                            (: 'import' 'schema' :)
      and $state[$p:lk] != 46207) then                      (: 'import' 'stylesheet' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 96) then                      (: 'declare' :)
            let $state := p:lookahead2W(153, $input, $state) (: S^WS | ('(' ':') | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'decimal-format' |
                                                                'default' | 'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] = 24928) then               (: 'declare' 'default' :)
                let $state := p:lookahead3W(145, $input, $state) (: S^WS | ('(' ':') | 'collation' | 'decimal-format' |
                                                                    'element' | 'function' | 'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:lk] = 6906208                       (: 'declare' 'default' 'element' :)
           or $state[$p:lk] = 7823712) then                 (: 'declare' 'default' 'function' :)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 36704) then              (: 'declare' 'namespace' :)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 127) then                (: 'import' :)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(45, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(224, $input, $state)        (: EOF | Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 96) then                          (: 'declare' :)
        let $state := p:lookahead2W(179, $input, $state)    (: EOF | S^WS | '!' | '!=' | '#' | '%' | '(' | ('(' ':') |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'context' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' |
                                                               'option' | 'or' | 'private' | 'to' | 'treat' | 'union' |
                                                               'variable' | '|' | '||' :)
        return $state
      else
        ($state[$p:l1], subsequence($state, $p:lk + 1))
    return
      if ($state[$p:lk] != 8288                             (: 'declare' '%' :)
      and $state[$p:lk] != 23392                            (: 'declare' 'context' :)
      and $state[$p:lk] != 30560                            (: 'declare' 'function' :)
      and $state[$p:lk] != 39008                            (: 'declare' 'option' :)
      and $state[$p:lk] != 42336                            (: 'declare' 'private' :)
      and $state[$p:lk] != 49504) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 96) then                      (: 'declare' :)
            let $state := p:lookahead2W(150, $input, $state) (: S^WS | '%' | ('(' ':') | 'context' | 'function' |
                                                                'option' | 'private' | 'variable' :)
            return $state
          else
            ($state[$p:l1], subsequence($state, $p:lk + 1))
        let $state :=
          if ($state[$p:lk] = 23392) then                   (: 'declare' 'context' :)
            let $state := p:parse-ContextItemDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 39008) then              (: 'declare' 'option' :)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AnnotatedDecl($input, $state)
            return $state
        let $state := p:lookahead1W(45, $input, $state)     (: S^WS | ('(' ':') | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return p:reduce($state, "Prolog", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(166, $input, $state)           (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'count' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'end' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'only' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'start' | 'to' | 'treat' |
                                                               'try' | 'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 21) then                            (: NCName^Token :)
      let $state := p:shift(21, $input, $state)             (: NCName^Token :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'and' :)
      let $state := p:shift(74, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'ascending' :)
      let $state := p:shift(76, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'case' :)
      let $state := p:shift(83, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'cast' :)
      let $state := p:shift(84, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'castable' :)
      let $state := p:shift(85, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'collation' :)
      let $state := p:shift(88, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'count' :)
      let $state := p:shift(93, $input, $state)             (: 'count' :)
      return $state
    else if ($state[$p:l1] = 97) then                       (: 'default' :)
      let $state := p:shift(97, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'descending' :)
      let $state := p:shift(100, $input, $state)            (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'div' :)
      let $state := p:shift(102, $input, $state)            (: 'div' :)
      return $state
    else if ($state[$p:l1] = 106) then                      (: 'else' :)
      let $state := p:shift(106, $input, $state)            (: 'else' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'empty' :)
      let $state := p:shift(107, $input, $state)            (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'end' :)
      let $state := p:shift(110, $input, $state)            (: 'end' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'eq' :)
      let $state := p:shift(111, $input, $state)            (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 113) then                      (: 'except' :)
      let $state := p:shift(113, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'for' :)
      let $state := p:shift(117, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'ge' :)
      let $state := p:shift(120, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'group' :)
      let $state := p:shift(122, $input, $state)            (: 'group' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'gt' :)
      let $state := p:shift(124, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'idiv' :)
      let $state := p:shift(125, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 131) then                      (: 'instance' :)
      let $state := p:shift(131, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 132) then                      (: 'intersect' :)
      let $state := p:shift(132, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'is' :)
      let $state := p:shift(133, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 136) then                      (: 'le' :)
      let $state := p:shift(136, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'let' :)
      let $state := p:shift(138, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'lt' :)
      let $state := p:shift(139, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 141) then                      (: 'mod' :)
      let $state := p:shift(141, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'ne' :)
      let $state := p:shift(145, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'only' :)
      let $state := p:shift(151, $input, $state)            (: 'only' :)
      return $state
    else if ($state[$p:l1] = 153) then                      (: 'or' :)
      let $state := p:shift(153, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 154) then                      (: 'order' :)
      let $state := p:shift(154, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 168) then                      (: 'return' :)
      let $state := p:shift(168, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: 'satisfies' :)
      let $state := p:shift(169, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 176) then                      (: 'stable' :)
      let $state := p:shift(176, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 177) then                      (: 'start' :)
      let $state := p:shift(177, $input, $state)            (: 'start' :)
      return $state
    else if ($state[$p:l1] = 184) then                      (: 'to' :)
      let $state := p:shift(184, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 185) then                      (: 'treat' :)
      let $state := p:shift(185, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 186) then                      (: 'try' :)
      let $state := p:shift(186, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 190) then                      (: 'union' :)
      let $state := p:shift(190, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(196, $input, $state)            (: 'where' :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(16, $input, $state)            (: 'module' :)
  let $state := p:shift(142, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(67, $input, $state)           (: S^WS | ('(' ':') | 'namespace' :)
  let $state := p:shift(143, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(167, $input, $state)          (: NCName^Token | S^WS | ('(' ':') | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'count' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'end' | 'eq' | 'except' | 'for' | 'ge' | 'group' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'only' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'start' | 'to' |
                                                               'treat' | 'try' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | ('(' ':') | '=' :)
  let $state := p:shift(60, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(32, $input, $state)           (: URILiteral | S^WS | ('(' ':') :)
  let $state := p:shift(8, $input, $state)                  (: URILiteral :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "ModuleDecl", $count)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Prolog($input, $state)
  return p:reduce($state, "LibraryModule", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(52, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(198, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | ('(' ':') | 'encoding' | 'version' :)
  let $state :=
    if ($state[$p:l1] = 109) then                           (: 'encoding' :)
      let $state := p:shift(109, $input, $state)            (: 'encoding' :)
      let $state := p:lookahead1W(34, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(194, $input, $state)            (: 'version' :)
      let $state := p:lookahead1W(34, $input, $state)       (: StringLiteral | S^WS | ('(' ':') :)
      let $state := p:shift(12, $input, $state)             (: StringLiteral :)
      let $state := p:lookahead1W(99, $input, $state)       (: S^WS | ('(' ':') | ';' | 'encoding' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 109) then                  (: 'encoding' :)
          let $state := p:shift(109, $input, $state)        (: 'encoding' :)
          let $state := p:lookahead1W(34, $input, $state)   (: StringLiteral | S^WS | ('(' ':') :)
          let $state := p:shift(12, $input, $state)         (: StringLiteral :)
          return $state
        else
          $state
      return $state
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | ('(' ':') | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "VersionDecl", $count)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(223, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 198) then                           (: 'xquery' :)
      let $state := p:lookahead2W(174, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'encoding' | 'eq' | 'except' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'lt' | 'mod' | 'ne' | 'or' | 'to' | 'treat' |
                                                               'union' | 'version' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 28102                          (: 'xquery' 'encoding' :)
          or $state[$p:lk] = 49862) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(223, $input, $state)          (: Wildcard | URIQualifiedName | IntegerLiteral |
                                                               DecimalLiteral | DoubleLiteral | StringLiteral |
                                                               QName^Token | S^WS | '$' | '(' | '(#' | ('(' ':') | '+' |
                                                               '-' | '.' | '..' | '/' | '//' | '<' | '<!--' | '<?' |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'count' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'end' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'function' | 'ge' | 'group' | 'gt' | 'idiv' |
                                                               'if' | 'import' | 'instance' | 'intersect' | 'is' |
                                                               'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'namespace-node' | 'ne' | 'node' | 'only' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'start' | 'switch' | 'text' | 'to' | 'treat' |
                                                               'try' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 142) then                           (: 'module' :)
      let $state := p:lookahead2W(170, $input, $state)      (: EOF | S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' |
                                                               '=' | '>' | '>=' | '>>' | '[' | 'and' | 'cast' |
                                                               'castable' | 'div' | 'eq' | 'except' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                               'mod' | 'namespace' | 'ne' | 'or' | 'to' | 'treat' |
                                                               'union' | '|' | '||' :)
      return $state
    else
      ($state[$p:l1], subsequence($state, $p:lk + 1))
  let $state :=
    if ($state[$p:lk] = 36750) then                         (: 'module' 'namespace' :)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MainModuleSequence($input, $state)
      return $state
  return p:reduce($state, "Module", $count)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(30, $input, $state)           (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-Module($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: EOF | S^WS | ('(' ':') :)
  let $state := p:shift(1, $input, $state)                  (: EOF :)
  return p:reduce($state, "XQuery", $count)
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

(: End :)
